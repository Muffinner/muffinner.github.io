<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galactic Guardians - Pixel Panic (Multiplayer Chat)</title>
    <style>
        /* --- CSS Styles --- */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Press Start 2P', cursive;
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        #game-container {
            position: relative;
            border: 5px solid #ddd;
            background-color: #111;
        }

        #gameCanvas {
            background-color: #000;
            display: block;
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #top-ui { /* Container for top UI elements (score, lives, instructions) */
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 10px;
            pointer-events: none; /* Make sure clicks pass through to canvas if needed below this area */
        }

        #score, #lives {
            font-size: 16px;
            text-shadow: 2px 2px 0 #000;
            pointer-events: auto; /* Re-enable pointer events for score/lives text if needed */
        }

        #instructions-button {
            font-size: 14px;
            padding: 8px 12px;
            pointer-events: auto; /* Re-enable pointer events for button */
        }
        #lives {
            text-align: right;
        }


        #chat-container { /* Chat Container */
            position: absolute;
            bottom: 0;
            left: 0;
            width: 300px; /* Adjust width as needed */
            height: 200px; /* Adjust height as needed */
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent chat background */
            border-top-right-radius: 10px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            pointer-events: auto; /* Ensure chat elements are interactive */
        }

        #chat-messages { /* Chat Message Display Area */
            flex-grow: 1;
            overflow-y: auto; /* Scrollable chat messages */
            padding-bottom: 5px;
            font-size: 14px;
            line-height: 1.4;
            word-break: break-word; /* Prevent long words from breaking layout */
        }

        #chat-input-container { /* Container for Input Area */
            display: flex;
            align-items: center;
            border-top: 1px solid #666;
            padding-top: 5px;
        }

        #chat-input { /* Chat Input Field */
            flex-grow: 1;
            background-color: transparent;
            border: none;
            color: #fff;
            font-family: inherit;
            font-size: 14px;
            padding: 5px;
            margin-right: 5px;
        }
        #chat-input:focus {
            outline: none; /* Remove default focus outline */
        }


        #instructions-popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.8);
            text-align: left;
            width: 60%;
            max-height: 80%;
            overflow-y: auto;
            z-index: 100;
        }

        #instructions-popup h2 {
            font-size: 24px;
            margin-top: 0;
            margin-bottom: 20px;
        }

        #instructions-popup p {
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        #instructions-popup ul {
            padding-left: 25px;
            margin-bottom: 15px;
        }

        #instructions-popup li {
            font-size: 16px;
            line-height: 1.6;
        }

        #close-instructions {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: #fff;
            font-size: 20px;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.3s;
        }

        #close-instructions:hover {
            opacity: 1;
        }


        #game-over, #start-screen {
            text-align: center;
            background-color: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        #game-over h1, #start-screen h1 {
            font-size: 32px;
            margin-bottom: 10px;
        }

        #game-over p, #start-screen p {
            font-size: 18px;
            margin-bottom: 20px;
        }

        button, #instructions-button, #close-instructions {
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover, #instructions-button:hover {
            background-color: #45a049;
        }

        .hidden {
            display: none !important;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="ui-overlay">
            <div id="top-ui">
                <div id="score">Score: 0</div>
                <div id="lives">Lives: 3</div>
                <button id="instructions-button">Instructions</button>
            </div>
            <div id="chat-container">  <!-- Chat Container Added -->
                <div id="chat-messages"></div>
                <div id="chat-input-container">
                    <input type="text" id="chat-input" placeholder="Type message and press Enter">
                </div>
            </div>
            <div id="instructions-popup" class="hidden">
                <h2>Galactic Guardians: Pixel Panic - Instructions</h2>
                <p>Welcome, Guardian! Earth is under attack from pixelated invaders! Your mission is to defend our planet and achieve the highest score possible.</p>

                <h3>Goal:</h3>
                <p>Survive waves of increasingly challenging enemies and defeat the Pixel Panic!</p>

                <h3>How to Play:</h3>
                <ul>
                    <li><strong>Move Left:</strong> Press the <strong>Left Arrow</strong> key or <strong>'A'</strong> key.</li>
                    <li><strong>Move Right:</strong> Press the <strong>Right Arrow</strong> key or <strong>'D'</strong> key.</li>
                    <li><strong>Shoot:</strong> Press the <strong>Spacebar</strong>.</li>
                </ul>

                <h3>Game Elements:</h3>
                <ul>
                    <li><strong>Enemies:</strong> Destroy red pixel enemies to earn points. Some enemies shoot back!</li>
                    <li><strong>Power-Ups:</strong> Collect cyan power-ups to gain temporary advantages:
                        <ul>
                            <li><strong>'F' (Fast Shoot):</strong> Increases your firing rate.</li>
                            <li><strong>'S' (Shield):</strong> Makes you temporarily invincible.</li>
                            <li><strong>'M' (Multi-Shot):</strong> Allows you to shoot multiple projectiles at once.</li>
                        </ul>
                    </li>
                    <li><strong>Lives:</strong> You start with 3 lives. Lose a life when hit by an enemy projectile. Game Over when you run out of lives!</li>
                </ul>

                <h3>Scoring:</h3>
                <ul>
                    <li><strong>Enemy Destroyed:</strong> 100 points</li>
                </ul>

                <p>Good luck, Guardian! Earth needs you!</p>
                <button id="close-instructions">Close</button>
            </div>
            <div id="game-over" class="hidden">
                <h1>Game Over</h1>
                <p id="final-score">Your Final Score: 0</p>
                <button id="restart-button">Restart</button>
            </div>
            <div id="start-screen">
                <h1>Galactic Guardians: Pixel Panic</h1>
                <h1>Multiplayer Chat Demo</h1> <p>(Simplified - Requires separate server setup)</p>
                <p>Defend Earth from the Pixel Invaders!</p>
                <button id="start-game-button">Start Game</button>
            </div>
        </div>
    </div>
    <script>
        /* --- JavaScript Code --- */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const gameOverScreen = document.getElementById('game-over');
        const finalScoreDisplay = document.getElementById('final-score');
        const restartButton = document.getElementById('restart-button');
        const startScreen = document.getElementById('start-screen');
        const startGameButton = document.getElementById('start-game-button');
        const instructionsButton = document.getElementById('instructions-button');
        const instructionsPopup = document.getElementById('instructions-popup');
        const closeInstructionsButton = document.getElementById('close-instructions');
        const chatMessagesDiv = document.getElementById('chat-messages'); // Chat message display
        const chatInput = document.getElementById('chat-input');         // Chat input field

        // --- Multiplayer ---
        let username = generateUsername(); // Generate AI username
        let websocket; // WebSocket connection variable

        function generateUsername() { // Simple AI Username Generator
            const adjectives = ["Pixelated", "Galactic", "Cosmic", "Neon", "Retro", "Space", "Star", "Cyber", "Quantum", "Atomic"];
            const nouns = ["Guardian", "Defender", "Invader", "Fighter", "Pilot", "Ranger", "Knight", "Warrior", "Soldier", "Captain"];
            const randomAdj = adjectives[Math.floor(Math.random() * adjectives.length)];
            const randomNoun = nouns[Math.floor(Math.random() * nouns.length)];
            return randomAdj + randomNoun;
        }

        function connectWebSocket() { // Function to connect to WebSocket Server
            // *** IMPORTANT: Replace with your actual WebSocket server address ***
            const websocketServerAddress = 'ws://localhost:8080'; // Example - Change if your server is different!

            websocket = new WebSocket(websocketServerAddress);

            websocket.onopen = () => {
                console.log('WebSocket connection opened');
                displayChatMessage('[System]', 'Connected to chat server!');
                sendChatMessage('[System]', `${username} joined the chat.`); // Announce join
            };

            websocket.onmessage = (event) => {
                const messageData = JSON.parse(event.data); // Expecting JSON messages from server
                displayChatMessage(messageData.sender, messageData.message);
            };

            websocket.onclose = () => {
                console.log('WebSocket connection closed');
                displayChatMessage('[System]', 'Disconnected from chat server.');
            };

            websocket.onerror = (error) => {
                console.error('WebSocket error:', error);
                displayChatMessage('[System]', 'Error connecting to chat server.');
            };
        }

        function sendChatMessage(sender, message) { // Function to send chat message
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                const messagePayload = { sender: sender, message: message };
                websocket.send(JSON.stringify(messagePayload)); // Send message as JSON
            } else {
                console.log('WebSocket not connected, cannot send message.');
                displayChatMessage('[System]', 'Cannot send message: Not connected to chat.');
            }
        }

        function displayChatMessage(sender, message) { // Function to display chat message in UI
            const messageElement = document.createElement('div');
            messageElement.textContent = `${sender}: ${message}`;
            chatMessagesDiv.appendChild(messageElement);
            chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight; // Auto-scroll to bottom
        }


        // --- Game Variables --- (Rest of your game variables remain the same)
        let score = 0;
        let lives = 3;
        let player;
        let enemies = [];
        let projectiles = [];
        let enemyProjectiles = [];
        let powerUps = [];
        let gameRunning = false;
        let level = 1;
        let enemySpawnInterval = 150;
        let powerUpSpawnInterval = 300;
        let lastEnemySpawnTime = 0;
        let lastPowerUpSpawnTime = 0;
        let gameFrame = 0;


        // --- Game Objects (Classes/Functions) --- (Rest of your game object classes remain the same - Player, Enemy, Projectile, PowerUp)
        class Player {
            constructor() {
                this.x = canvas.width / 2;
                this.y = canvas.height - 50;
                this.width = 30;
                this.height = 30;
                this.speed = 5;
                this.color = 'lime';
                this.isInvincible = false;
                this.invincibleTimer = 0;
                this.shootInterval = 25;
                this.lastShot = 0;
                this.multiShotActive = false;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                if (this.isInvincible && gameFrame % 10 < 5) {
                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(this.x - this.width / 2 - 5, this.y - this.height / 2 - 5, this.width + 10, this.height + 10);
                }
            }

            moveLeft() {
                this.x -= this.speed;
                if (this.x < this.width / 2) this.x = this.width / 2;
            }

            moveRight() {
                this.x += this.speed;
                if (this.x > canvas.width - this.width / 2) this.x = canvas.width - this.width / 2;
            }

            shoot() {
                if (gameFrame - this.lastShot > this.shootInterval) {
                    projectiles.push(new Projectile(this.x, this.y - this.height / 2, -5, 'white'));
                    if (this.multiShotActive) {
                        projectiles.push(new Projectile(this.x - 10, this.y - this.height / 2, -5, 'white'));
                        projectiles.push(new Projectile(this.x + 10, this.y - this.height / 2, -5, 'white'));
                    }
                    this.lastShot = gameFrame;
                    console.log("Player shot!");
                }
            }


            takeDamage() {
                if (!this.isInvincible) {
                    lives--;
                    livesDisplay.textContent = `Lives: ${lives}`;
                    if (lives <= 0) {
                        gameOver();
                    } else {
                        this.becomeInvincible();
                    }
                }
            }

            becomeInvincible() {
                this.isInvincible = true;
                this.invincibleTimer = 150;
            }

            updateInvincibility() {
                if (this.isInvincible) {
                    this.invincibleTimer--;
                    if (this.invincibleTimer <= 0) {
                        this.isInvincible = false;
                    }
                }
            }
        }


        // Enemy Ship
        class Enemy {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = 25;
                this.height = 25;
                this.speedX = 1;
                this.speedY = 0.5;
                this.color = 'red';
                this.type = type;
                this.directionX = 1;
                this.shootInterval = 100 + Math.random() * 200;
                this.lastShotTime = 0;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
            }

            update() {
                this.x += this.speedX * this.directionX;
                this.y += this.speedY;

                if (this.x <= this.width / 2 || this.x >= canvas.width - this.width / 2) {
                    this.directionX *= -1;
                    this.y += 15;
                }

                if (this.type === 'shooter' && gameFrame - this.lastShotTime > this.shootInterval) {
                    this.shoot();
                    this.lastShotTime = gameFrame;
                    this.shootInterval = 100 + Math.random() * 200;
                }

                if (this.y > canvas.height) {
                    this.y = -50;
                    this.x = Math.random() * canvas.width;
                }
            }

            shoot() {
                enemyProjectiles.push(new Projectile(this.x, this.y + this.height / 2, 3, 'orange'));
            }
        }


        // Projectile (for both player and enemies)
        class Projectile {
            constructor(x, y, speedY, color) {
                this.x = x;
                this.y = y;
                this.width = 5;
                this.height = 10;
                this.speedY = speedY;
                this.color = color;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
            }

            update() {
                this.y += this.speedY;
            }
        }

        // Power-Ups
        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = 20;
                this.height = 20;
                this.type = type;
                this.color = 'cyan';
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                ctx.fillStyle = 'black';
                ctx.font = '12px Press Start 2P';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.getSymbol(), this.x, this.y);
            }

            getSymbol() {
                switch (this.type) {
                    case 'fastShoot': return 'F';
                    case 'shield': return 'S';
                    case 'multiShot': return 'M';
                    default: return 'P';
                }
            }

            update() {
                this.y += 1;
            }
        }


        // --- Game Functions --- (Rest of your game functions remain the same - spawnEnemy, spawnPowerUp, updateScore, checkCollisions, isCollision, gameOver, resetGame, gameLoop)
        function spawnEnemy() {
            if (gameFrame - lastEnemySpawnTime > enemySpawnInterval) {
                const x = Math.random() * canvas.width;
                const y = -50;
                const enemyType = Math.random() < 0.8 ? 'basic' : 'shooter';
                enemies.push(new Enemy(x, y, enemyType));
                lastEnemySpawnTime = gameFrame;
                enemySpawnInterval = Math.max(50, enemySpawnInterval - 2);
            }
        }

        function spawnPowerUp() {
            if (gameFrame - lastPowerUpSpawnTime > powerUpSpawnInterval) {
                const x = Math.random() * canvas.width;
                const y = -50;
                const powerUpTypes = ['fastShoot', 'shield', 'multiShot'];
                const randomType = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                powerUps.push(new PowerUp(x, y, randomType));
                lastPowerUpSpawnTime = gameFrame;
                powerUpSpawnInterval = 300 + Math.random() * 200;
            }
        }

        function updateScore(points) {
            score += points;
            scoreDisplay.textContent = `Score: ${score}`;
            console.log(`Score updated to: ${score}`);
        }

        function checkCollisions() {
            for (let i = 0; i < projectiles.length; i++) {
                for (let j = 0; j < enemies.length; j++) {
                    if (isCollision(projectiles[i], enemies[j])) {
                        projectiles.splice(i, 1);
                        enemies.splice(j, 1);
                        i--;
                        updateScore(100);
                        console.log("Collision detected - Enemy destroyed!");
                        break;
                    }
                }
            }

            for (let i = 0; i < enemyProjectiles.length; i++) {
                if (isCollision(enemyProjectiles[i], player)) {
                    enemyProjectiles.splice(i, 1);
                    player.takeDamage();
                    i--;
                }
            }

            for (let i = 0; i < powerUps.length; i++) {
                if (isCollision(powerUps[i], player)) {
                    applyPowerUpEffect(powerUps[i].type);
                    powerUps.splice(i, 1);
                    i--;
                }
            }
        }

        function applyPowerUpEffect(type) {
            switch (type) {
                case 'fastShoot':
                    player.shootInterval = 10;
                    setTimeout(() => { player.shootInterval = 25; }, 5000);
                    break;
                case 'shield':
                    player.becomeInvincible();
                    break;
                case 'multiShot':
                    player.multiShotActive = true;
                    setTimeout(() => { player.multiShotActive = false; }, 7000);
                    break;
            }
            console.log(`Power-up activated: ${type}`);
        }


        function isCollision(rect1, rect2) {
            const collision = (
                rect1.x < rect2.x + rect2.width &&
                rect1.x + rect1.width > rect2.x &&
                rect1.y < rect2.y + rect2.height &&
                rect1.y + rect1.height > rect2.y
            );
            if (collision) {
                console.log("isCollision() - Collision detected!");
            }
            return collision;
        }

        function gameOver() {
            gameRunning = false;
            gameOverScreen.classList.remove('hidden');
            finalScoreDisplay.textContent = `Your Final Score: ${score}`;
        }

        function resetGame() {
            console.log('resetGame() called');
            score = 0;
            lives = 3;
            level = 1;
            enemySpawnInterval = 150;
            powerUpSpawnInterval = 300;
            lastEnemySpawnTime = 0;
            lastPowerUpSpawnTime = 0;
            gameFrame = 0;
            scoreDisplay.textContent = `Score: ${score}`;
            livesDisplay.textContent = `Lives: ${lives}`;
            enemies = [];
            projectiles = [];
            enemyProjectiles = [];
            powerUps = [];
            player = new Player();
            gameOverScreen.classList.add('hidden');
            startScreen.classList.add('hidden');
            gameRunning = true;
        }

        function gameLoop() {
            console.log('gameLoop() called');
            if (!gameRunning) {
                console.log('gameLoop() - gameRunning is false, exiting');
                return;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            spawnEnemy();
            spawnPowerUp();

            player.updateInvincibility();
            player.draw();

            enemies.forEach(enemy => {
                enemy.update();
                enemy.draw();
            });

            projectiles.forEach(projectile => {
                projectile.update();
                projectile.draw();
            });
            projectiles = projectiles.filter(projectile => projectile.y > 0);

            enemyProjectiles.forEach(projectile => {
                projectile.update();
                enemyProjectiles.draw();
            });
            enemyProjectiles = enemyProjectiles.filter(projectile => projectile.y < canvas.height);

            powerUps.forEach(powerUp => {
                powerUp.update();
                powerUp.draw();
            });
            powerUps = powerUps.filter(powerUp => powerUp.y < canvas.height);

            checkCollisions();

            gameFrame++;
            requestAnimationFrame(gameLoop);
        }

        // --- Input Handling --- (Input handling code remains the same)
        const keys = {};
        document.addEventListener('keydown', (e) => { keys[e.key] = true; });
        document.addEventListener('keyup', (e) => { keys[e.key] = false; });
        function handleInput() {
            if (keys['ArrowLeft'] || keys['a']) {
                player.moveLeft();
            }
            if (keys['ArrowRight'] || keys['d']) {
                player.moveRight();
            }
            if (keys[' '] || keys['Spacebar']) {
                player.shoot();
                keys[' '] = false;
                keys['Spacebar'] = false;
            }
        }


        // --- Event Listeners --- (Event listeners - added chat input listener)
        restartButton.addEventListener('click', () => { resetGame(); gameLoop(); });
        startGameButton.addEventListener('click', () => { console.log('Start Game button clicked!'); resetGame(); startScreen.classList.add('hidden'); gameLoop(); connectWebSocket(); }); // Connect WebSocket on game start!
        instructionsButton.addEventListener('click', () => { instructionsPopup.classList.remove('hidden'); });
        closeInstructionsButton.addEventListener('click', () => { instructionsPopup.classList.add('hidden'); });

        chatInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault();
                const message = chatInput.value.trim();
                if (message) {
                    sendChatMessage(username, message);
                    chatInput.value = '';
                }
            }
        });


        // --- Game Initialization and Start --- (Game init and loop remain mostly the same)
        function init() {
            player = new Player();
            livesDisplay.textContent = `Lives: ${lives}`;
            scoreDisplay.textContent = `Score: ${score}`;
            displayChatMessage('[System]', `Welcome, ${username}!`);

        }

        init();
        function update() { if (!gameRunning) return; handleInput(); }
        function mainGameLoop() { update(); gameLoop(); }
        setInterval(mainGameLoop, 1000/60);
    </script>
</body>
</html>