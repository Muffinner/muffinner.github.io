<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galactic Guardians - Pixel Panic</title>
    <style>
        /* --- CSS Styles --- */
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            background-color: #000; /* Dark background for space feel */
            font-family: 'Press Start 2P', cursive; /* Retro font - you'll need to include this or choose another */
            color: #fff;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh; /* Center vertically */
        }

        /* REMOVED @font-face BLOCK - Using <link> method now */

        #game-container {
            position: relative; /* For positioning UI elements */
            border: 5px solid #ddd; /* Optional border for the game area */
            background-color: #111; /* Slightly darker game background */
        }

        #gameCanvas {
            background-color: #000; /* Canvas background */
            display: block; /* Prevent extra spacing below canvas */
        }

        #ui-overlay {
            position: absolute; /* Overlay on top of the canvas */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            /* REMOVED pointer-events: none;  - This was making buttons unclickable! */
        }

        #score, #lives {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 16px;
            text-shadow: 2px 2px 0 #000; /* Add text shadow for retro look */
            pointer-events: none; /* Ensure it doesn't block canvas interactions */
        }
        #lives {
            left: auto;
            right: 10px;
        }

        #game-over, #start-screen {
            text-align: center;
            background-color: rgba(0, 0, 0, 0.8); /* Semi-transparent background */
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        #game-over h1, #start-screen h1 {
            font-size: 32px;
            margin-bottom: 10px;
        }

        #game-over p, #start-screen p {
            font-size: 18px;
            margin-bottom: 20px;
        }

        button {
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            padding: 10px 20px;
            background-color: #4CAF50; /* Green button */
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        button:hover {
            background-color: #45a049; /* Darker green on hover */
        }

        .hidden {
            display: none !important; /* Important to override other styles */
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="ui-overlay">
            <div id="score">Score: 0</div>
            <div id="lives">Lives: 3</div>
            <div id="game-over" class="hidden">
                <h1>Game Over</h1>
                <p id="final-score">Your Final Score: 0</p>
                <button id="restart-button">Restart</button>
            </div>
            <div id="start-screen">
                <h1>Galactic Guardians: Pixel Panic</h1>
                <p>Defend Earth from the Pixel Invaders!</p>
                <button id="start-game-button">Start Game</button>
            </div>
        </div>
    </div>
    <script>
        /* --- JavaScript Code --- */
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d'); // Get 2D rendering context
        const scoreDisplay = document.getElementById('score');
        const livesDisplay = document.getElementById('lives');
        const gameOverScreen = document.getElementById('game-over');
        const finalScoreDisplay = document.getElementById('final-score');
        const restartButton = document.getElementById('restart-button');
        const startScreen = document.getElementById('start-screen');
        const startGameButton = document.getElementById('start-game-button');

        // Game Variables
        let score = 0;
        let lives = 3;
        let player;
        let enemies = [];
        let projectiles = [];
        let enemyProjectiles = [];
        let powerUps = [];
        let gameRunning = false;
        let level = 1;
        let enemySpawnInterval = 150; // Adjust to control enemy spawn rate
        let powerUpSpawnInterval = 300; // Adjust power-up spawn rate
        let lastEnemySpawnTime = 0;
        let lastPowerUpSpawnTime = 0;
        let gameFrame = 0; // To time events independently of FPS

        // --- Game Objects (Classes/Functions) ---

        // Player Ship
        class Player {
            constructor() {
                this.x = canvas.width / 2;
                this.y = canvas.height - 50;
                this.width = 30;
                this.height = 30;
                this.speed = 5;
                this.color = 'lime'; // Player ship color
                this.isInvincible = false;
                this.invincibleTimer = 0;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                if (this.isInvincible && gameFrame % 10 < 5) { // Flicker effect when invincible
                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(this.x - this.width / 2 - 5, this.y - this.height / 2 - 5, this.width + 10, this.height + 10);
                }
            }

            moveLeft() {
                this.x -= this.speed;
                if (this.x < this.width / 2) this.x = this.width / 2; // Keep within bounds
            }

            moveRight() {
                this.x += this.speed;
                if (this.x > canvas.width - this.width / 2) this.x = canvas.width - this.width / 2; // Keep within bounds
            }

            shoot() {
                projectiles.push(new Projectile(this.x, this.y - this.height / 2, -5, 'white')); // Shoots upwards
            }

            takeDamage() {
                if (!this.isInvincible) {
                    lives--;
                    livesDisplay.textContent = `Lives: ${lives}`;
                    if (lives <= 0) {
                        gameOver();
                    } else {
                        this.becomeInvincible();
                    }
                }
            }

            becomeInvincible() {
                this.isInvincible = true;
                this.invincibleTimer = 150; // Invincibility lasts for 150 frames (adjust as needed)
            }

            updateInvincibility() {
                if (this.isInvincible) {
                    this.invincibleTimer--;
                    if (this.invincibleTimer <= 0) {
                        this.isInvincible = false;
                    }
                }
            }
        }


        // Enemy Ship
        class Enemy {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = 25;
                this.height = 25;
                this.speedX = 1; // Horizontal movement
                this.speedY = 0.5; // Vertical movement
                this.color = 'red'; // Enemy color
                this.type = type; // 'basic', 'fast', 'shooter' etc. for different behaviors
                this.directionX = 1; // 1 for right, -1 for left
                this.shootInterval = 100 + Math.random() * 200; // Random shooting interval for shooter types
                this.lastShotTime = 0;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
            }

            update() {
                this.x += this.speedX * this.directionX;
                this.y += this.speedY;

                // Basic side-to-side movement and descend
                if (this.x <= this.width / 2 || this.x >= canvas.width - this.width / 2) {
                    this.directionX *= -1; // Reverse direction
                    this.y += 15; // Move down slightly when hitting edge
                }

                if (this.type === 'shooter' && gameFrame - this.lastShotTime > this.shootInterval) {
                    this.shoot();
                    this.lastShotTime = gameFrame;
                    this.shootInterval = 100 + Math.random() * 200; // Vary next shot interval
                }

                if (this.y > canvas.height) {
                    // Enemy reached bottom - game over condition (optional, or reduce lives)
                    // gameOver(); // Uncomment if enemies reaching bottom is game over
                    this.y = -50; // Reset above screen instead, to keep game going (adjust as needed)
                    this.x = Math.random() * canvas.width;
                }
            }

            shoot() {
                enemyProjectiles.push(new Projectile(this.x, this.y + this.height / 2, 3, 'orange')); // Shoot downwards
            }
        }


        // Projectile (for both player and enemies)
        class Projectile {
            constructor(x, y, speedY, color) {
                this.x = x;
                this.y = y;
                this.width = 5;
                this.height = 10;
                this.speedY = speedY;
                this.color = color;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
            }

            update() {
                this.y += this.speedY;
            }
        }

        // Power-Ups
        class PowerUp {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = 20;
                this.height = 20;
                this.type = type; // 'fastShoot', 'shield', 'multiShot' etc.
                this.color = 'cyan'; // Power-up color
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
                ctx.fillStyle = 'black';
                ctx.font = '12px Press Start 2P'; // Use retro font
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.getSymbol(), this.x, this.y); // Display symbol
            }

            getSymbol() {
                switch (this.type) {
                    case 'fastShoot': return 'F';
                    case 'shield': return 'S';
                    case 'multiShot': return 'M';
                    default: return 'P'; // Default symbol
                }
            }

            update() {
                this.y += 1; // Move downwards
            }
        }


        // --- Game Functions ---

        function spawnEnemy() {
            if (gameFrame - lastEnemySpawnTime > enemySpawnInterval) {
                const x = Math.random() * canvas.width;
                const y = -50; // Start off-screen
                const enemyType = Math.random() < 0.8 ? 'basic' : 'shooter'; // 80% basic, 20% shooter
                enemies.push(new Enemy(x, y, enemyType));
                lastEnemySpawnTime = gameFrame;
                enemySpawnInterval = Math.max(50, enemySpawnInterval - 2); // Increase difficulty by reducing interval
            }
        }

        function spawnPowerUp() {
            if (gameFrame - lastPowerUpSpawnTime > powerUpSpawnInterval) {
                const x = Math.random() * canvas.width;
                const y = -50;
                const powerUpTypes = ['fastShoot', 'shield', 'multiShot'];
                const randomType = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
                powerUps.push(new PowerUp(x, y, randomType));
                lastPowerUpSpawnTime = gameFrame;
                powerUpSpawnInterval = 300 + Math.random() * 200; // Vary spawn interval
            }
        }


        function updateScore(points) {
            score += points;
            scoreDisplay.textContent = `Score: ${score}`;
        }

        function checkCollisions() {
            // Projectile - Enemy collisions
            for (let i = 0; i < projectiles.length; i++) {
                for (let j = 0; j < enemies.length; j++) {
                    if (isCollision(projectiles[i], enemies[j])) {
                        projectiles.splice(i, 1); // Remove projectile
                        enemies.splice(j, 1);     // Remove enemy
                        i--; // Adjust index after splice
                        updateScore(100); // Increase score
                        break; // Move to next projectile
                    }
                }
            }

            // Enemy Projectile - Player collision
            for (let i = 0; i < enemyProjectiles.length; i++) {
                if (isCollision(enemyProjectiles[i], player)) {
                    enemyProjectiles.splice(i, 1);
                    player.takeDamage();
                    i--;
                }
            }

            // Power-Up - Player collision
            for (let i = 0; i < powerUps.length; i++) {
                if (isCollision(powerUps[i], player)) {
                    applyPowerUpEffect(powerUps[i].type);
                    powerUps.splice(i, 1);
                    i--;
                }
            }
        }

        function applyPowerUpEffect(type) {
            switch (type) {
                case 'fastShoot':
                    player.shootInterval = 10; // Example: Increase fire rate
                    setTimeout(() => { player.shootInterval = 25; }, 5000); // Revert after 5 seconds
                    break;
                case 'shield':
                    player.becomeInvincible(); // Activate invincibility
                    break;
                case 'multiShot':
                    player.multiShotActive = true; // Implement multi-shot logic in player.shoot()
                    setTimeout(() => { player.multiShotActive = false; }, 7000); // Revert after 7 seconds
                    break;
            }
            console.log(`Power-up activated: ${type}`);
        }


        function isCollision(rect1, rect2) {
            return (
                rect1.x < rect2.x + rect2.width &&
                rect1.x + rect1.width > rect2.x &&
                rect1.y < rect2.y + rect2.height &&
                rect1.y + rect1.height > rect2.y
            );
        }

        function gameOver() {
            gameRunning = false;
            gameOverScreen.classList.remove('hidden');
            finalScoreDisplay.textContent = `Your Final Score: ${score}`;
        }

        function resetGame() {
            console.log('resetGame() called');
            score = 0;
            lives = 3;
            level = 1;
            enemySpawnInterval = 150;
            powerUpSpawnInterval = 300;
            lastEnemySpawnTime = 0;
            lastPowerUpSpawnTime = 0;
            gameFrame = 0;
            scoreDisplay.textContent = `Score: ${score}`;
            livesDisplay.textContent = `Lives: ${lives}`;
            enemies = [];
            projectiles = [];
            enemyProjectiles = [];
            powerUps = [];
            player = new Player(); // Re-initialize player
            gameOverScreen.classList.add('hidden');
            startScreen.classList.add('hidden'); // Hide start screen if it was visible
            gameRunning = true;
        }

        function gameLoop() {
            console.log('gameLoop() called');
            if (!gameRunning) {
                console.log('gameLoop() - gameRunning is false, exiting');
                return;
            } // Stop loop if game is not running

            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas

            spawnEnemy();
            spawnPowerUp();

            player.updateInvincibility();
            player.draw();

            enemies.forEach(enemy => {
                enemy.update();
                enemy.draw();
            });

            projectiles.forEach(projectile => {
                projectile.update();
                projectile.draw();
            });
            projectiles = projectiles.filter(projectile => projectile.y > 0); // Remove off-screen projectiles

            enemyProjectiles.forEach(projectile => {
                projectile.update();
                enemyProjectiles.draw();
            });
            enemyProjectiles = enemyProjectiles.filter(projectile => projectile.y < canvas.height); // Remove off-screen enemy projectiles


            powerUps.forEach(powerUp => {
                powerUp.update();
                powerUp.draw();
            });
            powerUps = powerUps.filter(powerUp => powerUp.y < canvas.height); // Remove off-screen power-ups


            checkCollisions();

            gameFrame++;
            requestAnimationFrame(gameLoop); // Loop the game
        }

        // --- Input Handling ---
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
        });
        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        function handleInput() {
            if (keys['ArrowLeft'] || keys['a']) {
                player.moveLeft();
            }
            if (keys['ArrowRight'] || keys['d']) {
                player.moveRight();
            }
            if (keys[' '] || keys['Spacebar']) { // Spacebar for shooting
                player.shoot();
                keys[' '] = false; // Prevent continuous shooting if space held down
                keys['Spacebar'] = false;
            }
        }

        // --- Event Listeners ---
        restartButton.addEventListener('click', () => {
            resetGame();
            gameLoop(); // Start the game loop again
        });

        startGameButton.addEventListener('click', () => {
            console.log('Start Game button clicked!');
            resetGame();
            startScreen.classList.add('hidden');
            gameLoop();
        });


        // --- Game Initialization and Start ---
        function init() {
            player = new Player(); // Initialize player
            livesDisplay.textContent = `Lives: ${lives}`;
            scoreDisplay.textContent = `Score: ${score}`;
            // Start screen is visible initially, game starts on button click
        }

        init(); // Call init to set up initial game state


        // --- Main Game Update Loop (runs every frame) ---
        function update() {
            if (!gameRunning) return; // Stop updating if game not running
            handleInput(); // Check for keyboard input
        }

        function mainGameLoop() {
            update(); // Update game state (input, movement, etc.)
            gameLoop(); // Render and other frame-based actions
        }

        setInterval(mainGameLoop, 1000/60); // Run at ~60 FPS (adjust as needed)
    </script>
</body>
</html>