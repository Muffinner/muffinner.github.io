--- START OF GIANT CODE BLOCK ---
<!-- index.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Weapon Masters Online</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="ui-container">
            <div id="chat-box">
                <h2>Chat</h2>
                <ul id="messages"></ul>
                <input type="text" id="chat-input" placeholder="Enter message...">
            </div>
            <div id="inventory-box">
                <h2>Inventory</h2>
                <ul id="inventory-items"></ul>
                <h3>Equipped Item: <span id="equipped-item-display">None</span></h3>
                <button id="equip-item-btn" style="display:none;">Equip Selected</button>
            </div>
            <div id="player-stats">
                <h2>Stats</h2>
                <p>Name: <span id="player-name-display"></span></p>
                <p>Health: <span id="player-health-display"></span></p>
                <p>Copper: <span id="player-copper-display"></span></p>
            </div>
            <div id="trade-ui" style="display:none;">
                <h2>Trade with <span id="trade-player-name"></span></h2>
                <div id="trade-offer">
                    <h3>Your Offer</h3>
                    <select id="offer-item-select">
                        <option value="-1">No Item</option>
                    </select>
                    <input type="number" id="offer-copper-input" value="0" min="0"> Copper
                </div>
                <div id="trade-request-display" style="display:none;">
                    <h3>Trade Request from <span id="trade-request-sender"></span></h3>
                    <p>Offering Item: <span id="trade-request-item">None</span></p>
                    <p>Offering Copper: <span id="trade-request-copper">0</span></p>
                    <button id="accept-trade-btn">Accept</button>
                    <button id="decline-trade-btn">Decline</button>
                </div>
                <div id="trade-actions">
                    <button id="request-trade-btn">Request Trade</button>
                    <button id="cancel-trade-btn" style="display:none;">Cancel Trade</button>
                </div>
            </div>
            <div id="players-online">
                <h2>Players Online</h2>
                <ul id="player-list"></ul>
            </div>
        </div>
    </div>
    <script src="/socket.io/socket.io.js"></script>
    <script src="script.js"></script>
</body>
</html>
<!-- style.css -->
<style>
body {
    font-family: Arial, sans-serif;
    margin: 0;
    background-color: #f0f0f0;
    overflow: hidden; /* Prevent scrollbars */
}

#game-container {
    display: flex;
    width: 100vw;
    height: 100vh;
}

#gameCanvas {
    background-color: #333; /* Dark background for the game world */
    border: 1px solid black;
}

#ui-container {
    width: 300px; /* Adjust as needed */
    background-color: #ddd;
    padding: 20px;
    box-sizing: border-box;
    overflow-y: auto; /* Scrollable UI if content overflows */
}

#chat-box {
    margin-bottom: 20px;
    border: 1px solid #ccc;
    padding: 10px;
    background-color: white;
    height: 200px; /* Fixed height for chat box */
    overflow-y: auto; /* Scrollable chat messages */
}

#chat-box h2 {
    margin-top: 0;
}

#messages {
    list-style: none;
    padding: 0;
    margin: 0;
}

#messages li {
    margin-bottom: 5px;
}

#chat-input {
    width: 100%;
    box-sizing: border-box;
    margin-top: 10px;
}

#inventory-box, #player-stats, #trade-ui, #players-online {
    border: 1px solid #ccc;
    padding: 10px;
    margin-bottom: 20px;
    background-color: white;
}

#inventory-box h2, #player-stats h2, #trade-ui h2, #players-online h2 {
    margin-top: 0;
}

#inventory-items {
    list-style: none;
    padding: 0;
    margin: 0;
}

#inventory-items li {
    margin-bottom: 5px;
    cursor: pointer; /* Indicate selectable items */
}

#inventory-items li.selected {
    background-color: #eee; /* Highlight selected item */
}


#trade-offer, #trade-request-display {
    margin-bottom: 10px;
    padding: 10px;
    border: 1px solid #eee;
    background-color: #f9f9f9;
}

#trade-offer h3, #trade-request-display h3 {
    margin-top: 0;
}

#trade-actions button, #trade-offer button, #trade-request-display button, #equip-item-btn {
    margin-right: 5px;
    padding: 8px 12px;
    cursor: pointer;
}

#players-online h2 {
    margin-top: 0;
}

#player-list {
    list-style: none;
    padding: 0;
    margin: 0;
}

#player-list li {
    margin-bottom: 5px;
}
</style>
<!-- script.js -->
<script>
// script.js

// ------------------------ Module: GameClient ------------------------ (SRP, DIP)
const GameClient = (function() {
    let socket;
    let canvas;
    let ctx;
    let player; // Local player data
    let players = {}; // All players in the game
    let items = {};
    let enemies = {};
    let playerNameDisplay = document.getElementById('player-name-display');
    let playerHealthDisplay = document.getElementById('player-health-display');
    let playerCopperDisplay = document.getElementById('player-copper-display');
    let inventoryItemsList = document.getElementById('inventory-items');
    let equippedItemDisplay = document.getElementById('equipped-item-display');
    let equipItemButton = document.getElementById('equip-item-btn');
    let messagesList = document.getElementById('messages');
    let chatInput = document.getElementById('chat-input');
    let playerListElement = document.getElementById('player-list');

    // Trade UI elements
    let tradeUI = document.getElementById('trade-ui');
    let tradePlayerNameDisplay = document.getElementById('trade-player-name');
    let offerItemSelect = document.getElementById('offer-item-select');
    let offerCopperInput = document.getElementById('offer-copper-input');
    let requestTradeButton = document.getElementById('request-trade-btn');
    let cancelTradeButton = document.getElementById('cancel-trade-btn');
    let tradeRequestDisplay = document.getElementById('trade-request-display');
    let tradeRequestSenderDisplay = document.getElementById('trade-request-sender');
    let tradeRequestItemDisplay = document.getElementById('trade-request-item');
    let tradeRequestCopperDisplay = document.getElementById('trade-request-copper');
    let acceptTradeButton = document.getElementById('accept-trade-btn');
    let declineTradeButton = document.getElementById('decline-trade-btn');

    const TILE_SIZE = 64;
    const DIRECTIONS = { DOWN: 0, LEFT: 1, RIGHT: 2, UP: 3, DOWN_LEFT: 4, DOWN_RIGHT: 5, UP_LEFT: 6, UP_RIGHT: 7 };

    let assetsLoaded = false;
    const playerSpriteSheet = new Image();
    const enemySpriteSheet = new Image();
    const itemImages = {
        sword: new Image(),
        shield: new Image(),
        potion: new Image(),
        staff: new Image()
    };
    const tileFloorImage = new Image();
    const tileWallImage = new Image();
    const tileDoorImage = new Image();

    let gameWorld = []; // Client-side game world representation

    let selectedInventoryIndex = -1; // Track selected inventory item for equipping


    function init() {
        canvas = document.getElementById('gameCanvas');
        ctx = canvas.getContext('2d');

        loadAssets();
    }

    function loadAssets() {
        playerSpriteSheet.src = 'assets/player_spritesheet.png'; // Replace with your sprite sheet path
        enemySpriteSheet.src = 'assets/enemy_spritesheet.png'; // Replace with your sprite sheet path
        itemImages.sword.src = 'assets/sword.png'; // Replace with your item image paths
        itemImages.shield.src = 'assets/shield.png';
        itemImages.potion.src = 'assets/potion.png';
        itemImages.staff.src = 'assets/staff.png';
        tileFloorImage.src = 'assets/tile_floor.png'; // Replace with your tile image paths
        tileWallImage.src = 'assets/tile_wall.png';
        tileDoorImage.src = 'assets/tile_door.png';

        let assetsToLoad = Object.keys(itemImages).length + 5; // Number of item images + player, enemy, and tiles

        const assetLoaded = () => {
            assetsToLoad--;
            if (assetsToLoad === 0) {
                assetsLoaded = true;
                connectToServer();
            }
        };

        playerSpriteSheet.onload = assetLoaded;
        enemySpriteSheet.onload = assetLoaded;
        tileFloorImage.onload = assetLoaded;
        tileWallImage.onload = assetLoaded;
        tileDoorImage.onload = assetLoaded;
        for (const itemName in itemImages) {
            itemImages[itemName].onload = assetLoaded;
        }
    }


    function connectToServer() {
        socket = io();

        // --- Socket Event Handlers --- (OCP - Easily extendable with new event handlers)

        socket.on('connect', () => {
            console.log('Connected to server');
        });

        socket.on('currentPlayers', (playersData) => {
            players = playersData;
            player = players[socket.id]; // Set local player
            updatePlayerUI(player);
            render();
        });

        socket.on('newPlayer', (playerData) => {
            players[playerData.id] = playerData;
            updatePlayerList();
            render();
        });

        socket.on('playerMoved', (playerData) => {
            if (players[playerData.playerId]) {
                players[playerData.playerId] = playerData; // Update player position
                render();
            }
        });

        socket.on('playerDisconnected', (playerId) => {
            delete players[playerId];
            updatePlayerList();
            render();
        });

        socket.on('currentItems', (itemsData) => {
            items = itemsData;
            renderItems();
        });

        socket.on('itemPickedUp', (data) => {
            if (data.playerId === socket.id) {
                player.inventory.push(data.item); // Update local player inventory
                updateInventoryUI();
            }
            delete items[data.itemId]; // Remove item from world
            renderItems();
        });

        socket.on('chatMessage', (data) => {
            addChatMessage(data.playerId, data.message);
        });

        socket.on('playerDamaged', (data) => {
            if (data.playerId === socket.id) {
                player.health = data.health;
                updatePlayerUI(player);
            }
            if (players[data.playerId]) {
                players[data.playerId].health = data.health; // Update other player health
            }
            render(); // Re-render to show damage
        });

        socket.on('playerHealed', (data) => {
            if (data.playerId === socket.id) {
                player.health = data.health;
                updatePlayerUI(player);
            }
            render();
        });

        socket.on('playerKilled', (playerId) => {
            if (playerId === socket.id) {
                alert("You have been defeated!"); // Basic game over
                // Optionally respawn logic here
            } else if (players[playerId]) {
                delete players[playerId]; // Remove from client side players list
                updatePlayerList();
                render();
            }
        });

        socket.on('updateEnemies', (enemiesData) => {
            enemies = enemiesData;
            renderEnemies();
        });

        socket.on('enemyKilled', (enemyId) => {
            delete enemies[enemyId];
            renderEnemies();
        });

        socket.on('enemyAttack', (data) => {
            //Visual feedback for enemy attack (optional)
            console.log(`Enemy ${data.enemyId} attacked!`);
        });

        socket.on('updateCopper', (copper) => {
            player.copper = copper;
            updatePlayerUI(player);
        });

        socket.on('tradeRequest', (data) => {
            displayTradeRequest(data);
        });

        socket.on('tradeDeclined', (data) => {
            hideTradeUI();
            alert(`Trade declined by player ${data.recipientId}`);
        });

        socket.on('tradeSuccess', (data) => {
            player.inventory = data.newInventory;
            player.copper = data.copper;
            updateInventoryUI();
            updatePlayerUI(player);
            hideTradeUI();
            alert('Trade successful!');
        });

        socket.on('tradeError', (message) => {
            alert(`Trade error: ${message}`);
            hideTradeUI();
        });

        socket.on('privateMessage', (data) => {
            addChatMessage(data.senderId, `(Private) ${data.message}`);
        });

        socket.on('privateMessageSent', (data) => {
             addChatMessage(socket.id, `(Private to ${data.recipientId}) ${data.message}`);
        });

        socket.on('chatError', (message) => {
            addChatMessage('Server', `Error: ${message}`);
        });

        // --- Input Handling ---
        setupInputListeners();
        setupChatInput();
        setupTradeUIListeners();
        setupInventoryUIListeners(); // Setup inventory UI interactions
        updatePlayerList(); // Initial player list update
        gameLoop(); // Start the game loop
    }

    function updatePlayerList() {
        playerListElement.innerHTML = ''; // Clear the list
        Object.values(players).forEach(p => {
            const li = document.createElement('li');
            li.textContent = `${p.name} (${p.id === socket.id ? 'You' : p.name})`;
            if (p.id !== socket.id) {
                const tradeButton = document.createElement('button');
                tradeButton.textContent = 'Trade';
                tradeButton.onclick = () => initiateTrade(p.id, p.name);
                li.appendChild(tradeButton);
            }
            playerListElement.appendChild(li);
        });
    }


    function setupInputListeners() {
        let keysPressed = {};
        document.addEventListener('keydown', (event) => {
            keysPressed[event.key] = true;
        });

        document.addEventListener('keyup', (event) => {
            keysPressed[event.key] = false;
        });

        setInterval(() => {
            if (!player || !assetsLoaded) return;
            let moving = false;
            let dx = 0;
            let dy = 0;
            let direction = player.direction;
            let frameIndex = player.frameIndex;

            if (keysPressed['w'] || keysPressed['ArrowUp']) {
                dy -= 1;
                direction = DIRECTIONS.UP;
                moving = true;
            }
            if (keysPressed['s'] || keysPressed['ArrowDown']) {
                dy += 1;
                direction = DIRECTIONS.DOWN;
                moving = true;
            }
            if (keysPressed['a'] || keysPressed['ArrowLeft']) {
                dx -= 1;
                direction = DIRECTIONS.LEFT;
                moving = true;
            }
            if (keysPressed['d'] || keysPressed['ArrowRight']) {
                dx += 1;
                direction = DIRECTIONS.RIGHT;
                moving = true;
            }

            if (moving) {
                frameIndex = (frameIndex + 1) % 8; // Cycle through frames
            } else {
                frameIndex = 0; // Reset to idle frame
            }

            if (dx !== 0 || dy !== 0 || moving !== player.moving || direction !== player.direction || frameIndex !== player.frameIndex) {
                const speed = 5;
                player.x += dx * speed;
                player.y += dy * speed;
                player.direction = direction;
                player.moving = moving;
                player.frameIndex = frameIndex;

                socket.emit('playerMovement', {
                    x: player.x,
                    y: player.y,
                    direction: direction,
                    frameIndex: frameIndex,
                    moving: moving
                });
            }
        }, 1000 / 60); // 60 times per second input check
    }

    function setupChatInput() {
        chatInput.addEventListener('keydown', (event) => {
            if (event.key === 'Enter') {
                const message = chatInput.value.trim();
                if (message) {
                    if (message.startsWith('/pm ')) {
                        const parts = message.substring(4).split(' ', 1);
                        const recipientId = parts[0];
                        const privateMessage = parts[1];
                        if (recipientId && privateMessage) {
                            socket.emit('privateMessage', { recipientId: recipientId, message: privateMessage });
                        } else {
                            addChatMessage('System', 'Usage: /pm [PlayerID] [Message]');
                        }

                    } else {
                        socket.emit('chatMessage', { message: message });
                    }
                    chatInput.value = '';
                }
            }
        });
    }

    function addChatMessage(playerId, message) {
        const li = document.createElement('li');
        li.textContent = `${playerId}: ${message}`;
        messagesList.appendChild(li);
        messagesList.scrollTop = messagesList.scrollHeight; // Scroll to bottom
    }

    function updatePlayerUI(currentPlayer) {
        playerNameDisplay.textContent = currentPlayer.name;
        playerHealthDisplay.textContent = currentPlayer.health + ' / ' + currentPlayer.maxHealth;
        playerCopperDisplay.textContent = currentPlayer.copper;
        updateInventoryUI();
    }

    function updateInventoryUI() {
        inventoryItemsList.innerHTML = ''; // Clear current list
        offerItemSelect.innerHTML = '<option value="-1">No Item</option>'; // Reset offer select
        equipItemButton.style.display = 'none'; // Hide equip button by default
        equippedItemDisplay.textContent = player.equippedItem ? player.equippedItem.type : 'None';


        player.inventory.forEach((item, index) => {
            const li = document.createElement('li');
            li.textContent = `${item.type} ${item.damage ? '(Damage: ' + item.damage + ')' : ''} ${item.defense ? '(Defense: ' + item.defense + ')' : ''} ${item.healing ? '(Healing: ' + item.healing + ')' : ''}`;
            li.dataset.index = index; // Store index for selection
            li.addEventListener('click', handleInventoryItemClick); // Add click handler
            inventoryItemsList.appendChild(li);

            const option = document.createElement('option');
            option.value = index;
            option.textContent = `${item.type} ${item.damage ? '(Damage: ' + item.damage + ')' : ''} ${item.defense ? '(Defense: ' + item.defense + ')' : ''} ${item.healing ? '(Healing: ' + item.healing + ')' : ''}`;
            offerItemSelect.appendChild(option);
        });

        // Re-highlight selected item if index is valid
        if (selectedInventoryIndex >= 0 && selectedInventoryIndex < player.inventory.length) {
            const selectedLi = inventoryItemsList.querySelector(`li[data-index="${selectedInventoryIndex}"]`);
            if (selectedLi) {
                selectedLi.classList.add('selected');
                equipItemButton.style.display = 'inline-block'; // Show equip button when item is selected
            }
        }
    }

    function setupInventoryUIListeners() {
        equipItemButton.addEventListener('click', equipSelectedItem);
    }


    function handleInventoryItemClick(event) {
        // Remove previous selection highlight
        const currentlySelected = inventoryItemsList.querySelector('li.selected');
        if (currentlySelected) {
            currentlySelected.classList.remove('selected');
        }

        const clickedLi = event.target;
        clickedLi.classList.add('selected');
        selectedInventoryIndex = parseInt(clickedLi.dataset.index, 10);
        equipItemButton.style.display = 'inline-block'; // Show equip button
    }


    function equipSelectedItem() {
        if (selectedInventoryIndex >= 0 && player.inventory[selectedInventoryIndex]) {
            player.equippedItem = player.inventory[selectedInventoryIndex];
            equippedItemDisplay.textContent = player.equippedItem.type;
            updateInventoryUI(); // Re-render inventory to reflect equipped item (optional visual cue)
            selectedInventoryIndex = -1; // Reset selection after equipping
            equipItemButton.style.display = 'none'; // Hide equip button after use
        }
    }


    function render() {
        if (!assetsLoaded) {
            requestAnimationFrame(render);
            return;
        }
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        renderGameWorld();
        renderItems();
        renderEnemies();
        renderPlayers();
        requestAnimationFrame(render);
    }

    function renderGameWorld() {
        const worldWidthInTiles = 200;
        const worldHeightInTiles = 200;

        if (gameWorld.length === 0) {
            // Initialize client-side game world once if not already initialized
            for (let y = 0; y < worldHeightInTiles; y++) {
                gameWorld[y] = [];
                for (let x = 0; x < worldWidthInTiles; x++) {
                    gameWorld[y][x] = 0; // Default to floor initially, server will update if needed
                }
            }
            // Replicate server-side world generation logic here if needed for client-side rendering details
            // (Or request world data from server if it becomes more complex)
             // Example: Replicate room and corridor generation (match server's logic in server.js)
            createRoomClient(20, 20, 40, 40);
            createRoomClient(80, 80, 60, 60);
            createRoomClient(20, 120, 50, 50);
            createRoomClient(120, 20, 60, 40);

            createCorridorClient(50, 30, 80, 30);
            createCorridorClient(30, 50, 30, 120);
            createCorridorClient(130, 50, 130, 80);
            createCorridorClient(70, 110, 120, 110);
        }


        for (let y = 0; y < worldHeightInTiles; y++) {
            for (let x = 0; x < worldWidthInTiles; x++) {
                let tileImage = tileFloorImage; // Default to floor
                if (gameWorld[y][x] === 1) { // TILE_WALL
                    tileImage = tileWallImage;
                } else if (gameWorld[y][x] === 2) { // TILE_DOOR
                    tileImage = tileDoorImage;
                }
                ctx.drawImage(tileImage, x * TILE_SIZE, y * TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }
        }
    }

    // Client-side room creation (match server logic)
    function createRoomClient(x, y, width, height) {
        for (let i = y; i < y + height; i++) {
            for (let j = x; j < x + width; j++) {
                if (i === y || i === y + height - 1 || j === x || j === x + width - 1) {
                    gameWorld[i][j] = 1; // TILE_WALL
                } else {
                    gameWorld[i][j] = 3; // TILE_FLOOR
                }
            }
        }
        gameWorld[y + Math.floor(height / 2)][x] = 2; // TILE_DOOR
    }

    // Client-side corridor creation (match server logic)
    function createCorridorClient(x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        const length = Math.max(Math.abs(dx), Math.abs(dy));

        for (let i = 0; i <= length; i++) {
            const x = x1 + Math.round(i * dx / length);
            const y = y1 + Math.round(i * dy / length);
            gameWorld[y][x] = 3; // TILE_FLOOR
        }
    }


    function renderPlayers() {
        for (const playerId in players) {
            const p = players[playerId];
            if (!p) continue;
            const spriteX = p.direction * 8 * 64; // Direction * frames * sprite width
            const spriteY = p.frameIndex * 64;      // Frame index * sprite height
            ctx.drawImage(playerSpriteSheet, spriteX, spriteY, 64, 64, p.x - p.width/2, p.y - p.height/2, p.width, p.height);

            // Health bar above player
            const healthBarWidth = p.width;
            const healthBarHeight = 5;
            const healthPercentage = p.health / p.maxHealth;
            ctx.fillStyle = 'red';
            ctx.fillRect(p.x - healthBarWidth / 2, p.y - p.height / 2 - 10, healthBarWidth, healthBarHeight);
            ctx.fillStyle = 'green';
            ctx.fillRect(p.x - healthBarWidth / 2, p.y - p.height / 2 - 10, healthBarWidth * healthPercentage, healthBarHeight);

            // Display player name (optional)
            ctx.fillStyle = 'white';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(p.name, p.x, p.y - p.height / 2 - 20);
        }
    }

    function renderItems() {
        for (const itemId in items) {
            const item = items[itemId];
            const itemImage = itemImages[item.type];
            if (itemImage) {
                ctx.drawImage(itemImage, item.x - 32, item.y - 32, 64, 64); // Adjust position and size as needed
            }
        }
    }

    function renderEnemies() {
        for (const enemyId in enemies) {
            const enemy = enemies[enemyId];
            if (!enemy) continue;
            const spriteX = enemy.direction * 8 * 64; // Direction * frames * sprite width
            const spriteY = enemy.frameIndex * 64;      // Frame index * sprite height
            ctx.drawImage(enemySpriteSheet, spriteX, spriteY, 64, 64, enemy.x - enemy.width/2, enemy.y - enemy.height/2, enemy.width, enemy.height);

             // Health bar above enemy
            const healthBarWidth = enemy.width;
            const healthBarHeight = 5;
            const healthPercentage = enemy.health / enemy.maxHealth;
            ctx.fillStyle = 'red';
            ctx.fillRect(enemy.x - healthBarWidth / 2, enemy.y - enemy.height / 2 - 10, healthBarWidth, healthBarHeight);
            ctx.fillStyle = 'green';
            ctx.fillRect(enemy.x - healthBarWidth / 2, enemy.y - enemy.height / 2 - 10, healthBarWidth * healthPercentage, healthBarHeight);
        }
    }

    function gameLoop() {
        if (!player || !assetsLoaded) {
            requestAnimationFrame(gameLoop);
            return;
        }

        handleItemInteraction(); // Check for item pickups
        handleCombat(); // Handle player attacks

        requestAnimationFrame(gameLoop);
    }

    function handleItemInteraction() {
        for (const itemId in items) {
            const item = items[itemId];
            const distance = Math.hypot(player.x - item.x, player.y - item.y);
            if (distance < TILE_SIZE / 2) { // Pickup radius
                socket.emit('pickupItem', itemId);
                break; // Pick up only one item at a time per frame
            }
        }
    }

    function handleCombat() {
        if (!player || !player.equippedItem) return; // Only attack if player has weapon equipped

        canvas.onclick = (event) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            // Check for player targets
            for (const targetPlayerId in players) {
                if (targetPlayerId === socket.id) continue; // Don't attack self
                const targetPlayer = players[targetPlayerId];
                if (!targetPlayer) continue;

                const distance = Math.hypot(mouseX - targetPlayer.x, mouseY - targetPlayer.y);
                if (distance < TILE_SIZE / 2) { // Click radius for player
                    socket.emit('attack', { targetId: targetPlayerId, weapon: player.equippedItem });
                    return; // Attack only one target
                }
            }

            // Check for enemy targets
            for (const enemyId in enemies) {
                const enemy = enemies[enemyId];
                if (!enemy) continue;
                const distance = Math.hypot(mouseX - enemy.x, mouseY - enemy.y);
                if (distance < TILE_SIZE / 2) { // Click radius for enemy
                    socket.emit('attack', { targetId: enemyId, weapon: player.equippedItem });
                    return; // Attack only one target
                }
            }
        };
    }

    // --- Trade UI Functions ---
    function setupTradeUIListeners() {
        requestTradeButton.addEventListener('click', sendTradeRequest);
        cancelTradeButton.addEventListener('click', cancelTradeRequest);
        acceptTradeButton.addEventListener('click', acceptTrade);
        declineTradeButton.addEventListener('click', declineTrade);
    }

    function initiateTrade(targetPlayerId, targetPlayerName) {
        tradeUI.style.display = 'block';
        tradePlayerNameDisplay.textContent = targetPlayerName;
        tradeRequestDisplay.style.display = 'none';
        requestTradeButton.style.display = 'block';
        cancelTradeButton.style.display = 'none';
        offerItemSelect.value = -1; // Reset item selection
        offerCopperInput.value = 0;
        tradeUI.dataset.targetPlayerId = targetPlayerId; // Store target player ID
    }

    function hideTradeUI() {
        tradeUI.style.display = 'none';
        tradeRequestDisplay.style.display = 'none';
        cancelTradeButton.style.display = 'none';
        requestTradeButton.style.display = 'block';
    }

    function sendTradeRequest() {
        const targetPlayerId = tradeUI.dataset.targetPlayerId;
        const offeredItemIndex = offerItemSelect.value;
        const offeredCopper = parseInt(offerCopperInput.value, 10);

        if (targetPlayerId) {
            socket.emit('tradeRequest', { recipientId: targetPlayerId, offeredItemIndex: offeredItemIndex, offeredCopper: offeredCopper });
            requestTradeButton.style.display = 'none';
            cancelTradeButton.style.display = 'block';
        }
    }

    function cancelTradeRequest() {
        hideTradeUI(); // For now, simple cancel, may need server-side cancel if trade requests are persisted
    }

    function displayTradeRequest(data) {
        tradeUI.style.display = 'block';
        tradeRequestDisplay.style.display = 'block';
        tradeRequestSenderDisplay.textContent = data.senderName;
        tradeRequestItemDisplay.textContent = data.offeredItem ? data.offeredItem.type : 'None';
        tradeRequestCopperDisplay.textContent = data.offeredCopper;
        tradeUI.dataset.tradeSenderId = data.senderId; // Store sender ID for accepting/declining
        requestTradeButton.style.display = 'none';
        cancelTradeButton.style.display = 'none';
    }

    function acceptTrade() {
        const senderId = tradeUI.dataset.tradeSenderId;
        const requestedItemIndex = -1; // Assume player is not requesting item for simplicity, can be extended
        const requestedCopper = 0; // Assume player is not requesting copper for simplicity

        if (senderId) {
            socket.emit('acceptTrade', { senderId: senderId, requestedItemIndex: requestedItemIndex, requestedCopper: requestedCopper });
        }
    }

    function declineTrade() {
        const senderId = tradeUI.dataset.tradeSenderId;
        if (senderId) {
            socket.emit('declineTrade', senderId);
            hideTradeUI();
        }
    }


    return {
        init: init
    };
})();

document.addEventListener('DOMContentLoaded', () => {
    GameClient.init();
});
</script>
--- END OF GIANT CODE BLOCK ---