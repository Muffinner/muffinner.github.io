<!DOCTYPE html>
<html>
<head>
    <title>Simple FPS Shooter</title>
    <style>
        /* --- CSS: css/style.css --- */
        body {
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
            background-color: #222; /* Dark background */
        }

        #gameCanvas {
            display: block; /* Remove extra space below canvas */
            background-color: #333; /* Canvas background */
        }
        /* --- End CSS: css/style.css --- */
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script>
        /* --- JavaScript: js/player.js --- */
        class Player {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 20;
                this.height = 20;
                this.color = 'blue';
                this.speed = 150; // pixels per second
                this.health = 100;
                this.directionX = 0;
                this.directionY = 0;
            }

            update(deltaTime, level) {
                // Movement based on input direction
                this.x += this.directionX * this.speed * deltaTime;
                this.y += this.directionY * this.speed * deltaTime;

                // Collision detection with level walls
                this.collideWithWalls(level);
            }

            collideWithWalls(level) {
                level.walls.forEach(wall => {
                    if (this.checkCollision(wall)) {
                        // Very basic collision response - just stop movement
                        if (this.directionX > 0) this.x = wall.x - this.width; // Right collision
                        if (this.directionX < 0) this.x = wall.x + wall.width; // Left collision
                        if (this.directionY > 0) this.y = wall.y - this.height; // Bottom collision
                        if (this.directionY < 0) this.y = wall.y + wall.height; // Top collision
                    }
                });
            }

            checkCollision(wall) {
                return (
                    this.x < wall.x + wall.width &&
                    this.x + this.width > wall.x &&
                    this.y < wall.y + wall.height &&
                    this.y + this.height > wall.y
                );
            }

            takeDamage(damage) {
                this.health -= damage;
                if (this.health < 0) {
                    this.health = 0; // Game over logic would go here
                    console.log("Game Over!");
                }
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }
        /* --- End JavaScript: js/player.js --- */
    </script>

    <script>
        /* --- JavaScript: js/weapon.js --- */
        class Weapon {
            constructor(name, damage, fireRate) {
                this.name = name;
                this.damage = damage;
                this.fireRate = fireRate; // Shots per second
                this.lastFireTime = 0;
            }

            shoot(player, enemies, currentTime) {
                if (currentTime - this.lastFireTime > 1 / this.fireRate) {
                    this.lastFireTime = currentTime;
                    console.log(`${this.name} fired!`);
                    // Implement projectile or raycast logic here to hit enemies
                    this.handleShootingLogic(player, enemies);
                }
            }

            handleShootingLogic(player, enemies) {
                // This is a placeholder for actual shooting logic.
                // Subclasses will implement specific shooting behaviors.
                console.log("Base weapon shooting logic - override in subclasses");
            }
        }

        class Pistol extends Weapon {
            constructor() {
                super('Pistol', 10, 2); // Name, Damage, Fire Rate
            }

            handleShootingLogic(player, enemies) {
                console.log("Pistol shooting logic - finding closest enemy (simplified)");
                let closestEnemy = null;
                let minDistance = Infinity;

                enemies.forEach(enemy => {
                    const distance = Math.sqrt(Math.pow(enemy.x - player.x, 2) + Math.pow(enemy.y - player.y, 2));
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestEnemy = enemy;
                    }
                });

                if (closestEnemy) {
                    closestEnemy.takeDamage(this.damage);
                    console.log(`Pistol hit enemy! Damage: ${this.damage}`);
                } else {
                    console.log("No enemies in range for Pistol.");
                }
            }
        }
        /* --- End JavaScript: js/weapon.js --- */
    </script>

    <script>
        /* --- JavaScript: js/level.js --- */
        class LevelGenerator {
            constructor(width, height) {
                this.levelWidth = width;
                this.levelHeight = height;
                this.cellSize = 50; // Size of each grid cell for level generation
            }

            generateLevel() {
                const level = { walls: [] };
                const gridWidth = Math.floor(this.levelWidth / this.cellSize);
                const gridHeight = Math.floor(this.levelHeight / this.cellSize);

                // Simple random wall generation
                for (let x = 0; x < gridWidth; x++) {
                    for (let y = 0; y < gridHeight; y++) {
                        if (Math.random() < 0.2) { // 20% chance of a wall
                            level.walls.push({
                                x: x * this.cellSize,
                                y: y * this.cellSize,
                                width: this.cellSize,
                                height: this.cellSize
                            });
                        }
                    }
                }
                return level;
            }
        }
        /* --- End JavaScript: js/level.js --- */
    </script>

    <script>
        /* --- JavaScript: js/enemy.js --- */
        class Enemy {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 20;
                this.height = 20;
                this.color = 'red';
                this.speed = 80;
                this.health = 50;
            }

            update(deltaTime, player, level) {
                // Simple AI: Move towards player
                const dx = player.x - this.x;
                const dy = player.y - this.y;
                const angle = Math.atan2(dy, dx);

                this.x += Math.cos(angle) * this.speed * deltaTime;
                this.y += Math.sin(angle) * this.speed * deltaTime;

                this.collideWithWalls(level); // Prevent enemies from going through walls
            }

            collideWithWalls(level) {
                level.walls.forEach(wall => {
                    if (this.checkCollision(wall)) {
                        // Simple collision response - move slightly away
                        const dx = this.x - wall.x;
                        const dy = this.y - wall.y;
                        const angle = Math.atan2(dy, dx);
                        this.x += Math.cos(angle) * 10 * deltaTime; // Move away slightly
                        this.y += Math.sin(angle) * 10 * deltaTime;
                    }
                });
            }

            checkCollision(wall) {
                return (
                    this.x < wall.x + wall.width &&
                    this.x + this.width > wall.x &&
                    this.y < wall.y + wall.height &&
                    this.y + this.height > wall.y
                );
            }

            takeDamage(damage) {
                this.health -= damage;
                if (this.health < 0) {
                    this.health = 0;
                    console.log("Enemy defeated!");
                }
            }

            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }
        /* --- End JavaScript: js/enemy.js --- */
    </script>

    <script>
        /* --- JavaScript: js/ui.js --- */
        class UI {
            constructor(player, currentWeapon) {
                this.player = player;
                this.currentWeapon = currentWeapon;
            }

            update(player, currentWeapon) {
                this.player = player; // Update player reference if needed
                this.currentWeapon = currentWeapon; // Update weapon reference
            }

            draw(ctx) {
                ctx.fillStyle = 'white';
                ctx.font = '16px Arial';
                ctx.fillText(`Health: ${this.player.health}`, 10, 20);
                ctx.fillText(`Weapon: ${this.currentWeapon.name}`, 10, 40);
                // Add more UI elements here (ammo, score, etc.)
            }
        }
        /* --- End JavaScript: js/ui.js --- */
    </script>

    <script>
        /* --- JavaScript: js/input.js --- */
        class InputHandler {
            constructor(player, currentWeapon, canvas) {
                this.player = player;
                this.currentWeapon = currentWeapon;
                this.canvas = canvas;
                this.keys = []; // Track pressed keys

                window.addEventListener('keydown', (e) => {
                    if (this.keys.indexOf(e.key) === -1) {
                        this.keys.push(e.key);
                    }
                    this.handleKeyboardInput(e.key);
                });

                window.addEventListener('keyup', (e) => {
                    this.keys = this.keys.filter(key => key !== e.key);
                    this.handleKeyboardInput(e.key, true); // Pass keyup event
                });

                this.canvas.addEventListener('mousedown', (e) => {
                    this.handleMouseClick(e);
                });
            }

            updateWeapon(newWeapon) {
                this.currentWeapon = newWeapon; // To change weapons later if needed
            }

            handleKeyboardInput(key, keyUp = false) {
                switch (key) {
                    case 'w':
                    case 'W':
                        this.player.directionY = keyUp ? (this.keys.includes('s') || this.keys.includes('S') ? 1 : 0) : -1;
                        break;
                    case 's':
                    case 'S':
                        this.player.directionY = keyUp ? (this.keys.includes('w') || this.keys.includes('W') ? -1 : 0) : 1;
                        break;
                    case 'a':
                    case 'A':
                        this.player.directionX = keyUp ? (this.keys.includes('d') || this.keys.includes('D') ? 1 : 0) : -1;
                        break;
                    case 'd':
                    case 'D':
                        this.player.directionX = keyUp ? (this.keys.includes('a') || this.keys.includes('A') ? -1 : 0) : 1;
                        break;
                }
            }

            handleMouseClick(event) {
                const currentTime = performance.now() / 1000; // Convert to seconds
                this.currentWeapon.shoot(game.enemies, currentTime); // Assuming 'game' is globally accessible (for now - improve later)
            }
        }
        /* --- End JavaScript: js/input.js --- */
    </script>

    <script>
        /* --- JavaScript: js/game.js --- */
        // game.js - Orchestrates the game, main loop, and initialization

        class Game {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.player = new Player(this.canvas.width / 2, this.canvas.height / 2);
                this.levelGenerator = new LevelGenerator(this.canvas.width, this.canvas.height);
                this.level = this.levelGenerator.generateLevel(); // Generate procedural level
                this.enemies = [new Enemy(100, 100), new Enemy(700, 500)]; // Example enemies
                this.weapons = {
                    pistol: new Pistol() // Example weapon
                    // Add more weapons here later (e.g., shotgun, rifle)
                };
                this.currentWeapon = this.weapons.pistol; // Start with pistol
                this.ui = new UI(this.player, this.currentWeapon);
                this.inputHandler = new InputHandler(this.player, this.currentWeapon, this.canvas);

                // Make game.enemies globally accessible for input.js (TEMPORARY - improve later with better state management)
                window.game = this; // BAD PRACTICE for large projects, but okay for this simple example to avoid module issues quickly.

                this.lastTime = 0;
                this.gameLoop();
            }

            gameLoop(timestamp) {
                const deltaTime = timestamp - this.lastTime;
                this.lastTime = timestamp;

                this.update(deltaTime);
                this.draw();

                requestAnimationFrame(this.gameLoop.bind(this));
            }

            update(deltaTime) {
                this.player.update(deltaTime, this.level);
                this.enemies.forEach(enemy => enemy.update(deltaTime, this.player, this.level));

                // Weapon firing logic is handled in InputHandler based on player input
                // (see input.js)

                // Enemy collision with player (simple example)
                this.enemies.forEach(enemy => {
                    if (this.checkCollision(this.player, enemy)) {
                        this.player.takeDamage(10); // Example damage
                    }
                });

                // Check if enemies are dead and remove them (example)
                this.enemies = this.enemies.filter(enemy => enemy.health > 0);

                this.ui.update(this.player, this.currentWeapon); // Update UI elements
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw Level
                this.drawLevel();

                // Draw Enemies
                this.enemies.forEach(enemy => enemy.draw(this.ctx));

                // Draw Player
                this.player.draw(this.ctx);

                // Draw UI
                this.ui.draw(this.ctx);
            }

            drawLevel() {
                this.ctx.fillStyle = '#555'; // Wall color
                this.level.walls.forEach(wall => {
                    this.ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
                });
            }

            checkCollision(entity1, entity2) {
                // Simple AABB collision detection (Axis-Aligned Bounding Boxes)
                return (
                    entity1.x < entity2.x + entity2.width &&
                    entity1.x + entity1.width > entity2.x &&
                    entity1.y < entity2.y + entity2.height &&
                    entity1.y + entity1.height > entity2.y
                );
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            const game = new Game('gameCanvas');
        });
        /* --- End JavaScript: js/game.js --- */
    </script>

</body>
</html>