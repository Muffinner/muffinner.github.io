<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Space Shooter</title>
    <style>
        body {
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: black;
            overflow: hidden; /* Prevent scrollbars */
        }

        canvas {
            background-color: #222; /* Dark gray background for the game */
            border: 1px solid white; /* Optional border */
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        // renderer.js
        class Renderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
            }

            clear() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }

            draw(gameObject) {
                if (gameObject.image) {
                    this.ctx.drawImage(
                        gameObject.image,
                        gameObject.x,
                        gameObject.y,
                        gameObject.width,
                        gameObject.height
                    );
                } else {
                    // Fallback for objects without images (e.g., draw a rectangle)
                    this.ctx.fillStyle = gameObject.color || 'white';
                    this.ctx.fillRect(gameObject.x, gameObject.y, gameObject.width, gameObject.height);
                }
            }

            drawText(text, x, y, color = 'white', font = '16px Arial') {
                this.ctx.fillStyle = color;
                this.ctx.font = font;
                this.ctx.fillText(text, x, y);
            }
        }

        // input.js
        class InputHandler {
            constructor() {
                this.keys = {};
                window.addEventListener('keydown', this.handleKeyDown.bind(this));
                window.addEventListener('keyup', this.handleKeyUp.bind(this));
                window.addEventListener('mousedown', this.handleMouseDown.bind(this));
                window.addEventListener('mouseup', this.handleMouseUp.bind(this));
            }

            handleKeyDown(event) {
                this.keys[event.code] = true;
            }

            handleKeyUp(event) {
                this.keys[event.code] = false;
            }

            handleMouseDown(event) {
                this.keys['Mouse' + event.button] = true;  //e.g., 'Mouse0' for left click
            }

            handleMouseUp(event) {
                this.keys['Mouse' + event.button] = false;
            }

            isKeyDown(key) {
                return this.keys[key] || false;
            }

            isMouseButtonDown(button) {
                return this.keys['Mouse' + button] || false;
            }
        }

        // bullet.js
        class Bullet {
            constructor(x, y, velocityY, width = 5, height = 10, color = 'yellow') {
                this.x = x - width / 2;
                this.y = y;
                this.velocityY = velocityY;
                this.width = width;
                this.height = height;
                this.color = color;
                this.isActive = true;  // Flag for removing off-screen bullets
                this.damage = 10; // Damage this bullet deals
            }

            update(deltaTime) {
                this.y += this.velocityY * deltaTime;

                // Check if bullet is off-screen
                if (this.y + this.height < 0 || this.y > 600) {
                    this.isActive = false;
                }
            }
            collidesWith(other) {
                return (
                    this.x < other.x + other.width &&
                    this.x + this.width > other.x &&
                    this.y < other.y + other.height &&
                    this.y + this.height > other.y
                );
            }
        }

        class BulletSpawner {
            constructor() {
                this.bullets = [];
            }

            spawnBullet(x, y, velocityY) {
                this.bullets.push(new Bullet(x, y, velocityY));
            }

            update(deltaTime) {
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    this.bullets[i].update(deltaTime);
                    if (!this.bullets[i].isActive) {
                        this.bullets.splice(i, 1); // Remove inactive bullets
                    }
                }
            }

            render(renderer) {
                this.bullets.forEach(bullet => renderer.draw(bullet));
            }

            checkCollisions(targets) {
                for (let i = this.bullets.length - 1; i >= 0; i--) {
                    const bullet = this.bullets[i];
                    for (let j = targets.length - 1; j >= 0; j--) {
                        const target = targets[j];
                        if (bullet.collidesWith(target)) {
                            target.takeDamage(bullet.damage);
                            bullet.isActive = false; // Remove bullet on collision
                            break; // Exit inner loop after collision
                        }
                    }
                }
            }
        }

        // player.js
        class Player {
            constructor(x, y, width, height, speed, image, inputHandler, bulletSpawner) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.speed = speed;
                this.image = image;
                this.input = inputHandler; // Dependency Injection
                this.bulletSpawner = bulletSpawner; // Dependency Injection
                this.shootCooldown = 250; //ms
                this.lastShotTime = 0;
                this.health = 100; // add healt
            }

            update(deltaTime) {
                // Movement
                if (this.input.isKeyDown('ArrowUp') || this.input.isKeyDown('KeyW')) {
                    this.y -= this.speed * deltaTime;
                }
                if (this.input.isKeyDown('ArrowDown') || this.input.isKeyDown('KeyS')) {
                    this.y += this.speed * deltaTime;
                }
                if (this.input.isKeyDown('ArrowLeft') || this.input.isKeyDown('KeyA')) {
                    this.x -= this.speed * deltaTime;
                }
                if (this.input.isKeyDown('ArrowRight') || this.input.isKeyDown('KeyD')) {
                    this.x += this.speed * deltaTime;
                }
                // Keep player within bounds
                this.x = Math.max(0, Math.min(this.x, 800 - this.width)); // Assuming canvas width is 800
                this.y = Math.max(0, Math.min(this.y, 600 - this.height));  // Assuming canvas height is 600

                // Shooting (with cooldown)
                const now = Date.now();
                if ((this.input.isKeyDown('Space') || this.input.isMouseButtonDown(0)) && now - this.lastShotTime > this.shootCooldown) {
                    this.bulletSpawner.spawnBullet(this.x + this.width / 2, this.y, -500); // Pass negative velocity for upward movement.
                    this.lastShotTime = now;
                }

            }
            takeDamage(damage) {
                this.health -= damage;
                if (this.health <= 0) {
                    // Handle player death (e.g., remove from game, show game over)
                    this.health = 0; // Ensure health doesn't go below 0
                    console.log("Player died!");
                }
            }
        }


        // enemy.js
        class Enemy {
            constructor(x, y, width, height, speed, image) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.speed = speed;
                this.image = image;
                this.isActive = true; // For removing off-screen/dead enemies.
                this.health = 30; // add health
            }

            update(deltaTime) {
                this.y += this.speed * deltaTime;
                if (this.y > 600) { // Assuming canvas height is 600
                    this.isActive = false;
                }
            }
            takeDamage(damage) {
                this.health -= damage;
                if (this.health <= 0) {
                    this.isActive = false; // Mark for removal
                }
            }
        }

        // ui.js
        class UI {
            constructor(player, renderer) {
                this.player = player;
                this.renderer = renderer; // Use the renderer for drawing
            }

            update() {
                // Display score, health, etc.
                this.renderer.drawText(`Health: ${this.player.health}`, 10, 20);
                // this.renderer.drawText(`Score: ${this.score}`, 10, 40); // Example score display

            }
        }


        // network.js
        class Network {
            constructor() {
                this.socket = null;
                this.players = {}; // Store other players' data
                this.playerId = null;  // Our own player ID
            }

            connect(serverAddress) {
                this.socket = new WebSocket(serverAddress);

                this.socket.onopen = () => {
                    console.log('Connected to server');
                    // Send initial player data (position, etc.)
                    // this.sendPlayerData();
                };

                this.socket.onmessage = (event) => {
                    this.handleMessage(event.data);
                };

                this.socket.onclose = () => {
                    console.log('Disconnected from server');
                };

                this.socket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                };
            }
             handleMessage(message) {
                const data = JSON.parse(message);
                if (data.type ==='id'){
                  this.playerId = data.id;
                }
                else if (data.type === 'playerUpdate') {
                //Update other players
                if (data.id !== this.playerId) {
                    this.players[data.id] = data.playerData; // Assuming playerData has x, y, etc.
                }
              } else if (data.type === 'playerDisconnect') {
                //handle a disconnected player.
                delete this.players[data.id]
              }
              // Handle other message types (new players, bullets, etc.)
            }

            send(data) {
                if (this.socket && this.socket.readyState === WebSocket.OPEN) {
                    this.socket.send(JSON.stringify(data));
                }
            }

            sendPlayerData(playerData) {
                this.send({ type: 'playerUpdate', id: this.playerId, playerData });
            }

        }

        // game.js
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.canvas.width = 800;
                this.canvas.height = 600;
                this.renderer = new Renderer(this.canvas);
                this.input = new InputHandler();
                this.bulletSpawner = new BulletSpawner();

                const playerImage = new Image();
                // VERY IMPORTANT: Use the placeholder for now.  Replace later!
                playerImage.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';
                this.player = new Player(this.canvas.width / 2 - 25, this.canvas.height - 75, 50, 50, 200, playerImage, this.input, this.bulletSpawner);

                this.enemies = [];
                this.enemySpawnInterval = 2000; // Spawn an enemy every 2 seconds
                this.lastEnemySpawnTime = 0;
                this.enemyImage = new Image();
                // VERY IMPORTANT: Use the placeholder for now.  Replace later!
                this.enemyImage.src = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=';

                this.ui = new UI(this.player, this.renderer);  // create UI
                this.network = new Network(); //create network
                this.network.connect('ws://localhost:8080')  // IMPORTANT: Replace with your server address!  This is just an example.

                this.lastFrameTime = 0;
                this.gameLoop = this.gameLoop.bind(this); // Bind the gameLoop to the Game instance

            }

            spawnEnemy() {
                const x = Math.random() * (this.canvas.width - 50); // Random X position
                const enemy = new Enemy(x, 0, 50, 50, 50, this.enemyImage); // Use enemyImage
                this.enemies.push(enemy);
            }

            gameLoop(timestamp) {
                const deltaTime = (timestamp - this.lastFrameTime) / 1000; // Delta time in seconds
                this.lastFrameTime = timestamp;

                this.update(deltaTime);
                this.render();
                requestAnimationFrame(this.gameLoop);
            }

            update(deltaTime) {
                const now = Date.now();
                if (now - this.lastEnemySpawnTime > this.enemySpawnInterval) {
                    this.spawnEnemy();
                    this.lastEnemySpawnTime = now;
                }

                this.player.update(deltaTime);
                this.bulletSpawner.update(deltaTime);  //Update the bulltes

                // Enemy update and removal
                for (let i = this.enemies.length - 1; i >= 0; i--) {
                    this.enemies[i].update(deltaTime);
                    if (!this.enemies[i].isActive) {
                        this.enemies.splice(i, 1);
                    }
                }
                this.bulletSpawner.checkCollisions(this.enemies);  //Check for collisions
                this.ui.update(); // Update UI

                // Send player data to server (throttled)
                if (this.network.playerId) { // Only send if we have an ID
                    this.network.sendPlayerData({ x: this.player.x, y: this.player.y, health: this.player.health });
                }

            }

            render() {
                this.renderer.clear();
                this.renderer.draw(this.player);
                this.bulletSpawner.render(this.renderer);  // Render all bullets
                this.enemies.forEach(enemy => this.renderer.draw(enemy)); // Draw enemies


                // Render other players (simplified for now)
                for (const playerId in this.network.players) {
                    if(this.network.playerId!== playerId){
                      const otherPlayer = this.network.players[playerId];
                      // You might have a different image/color for other players
                      this.renderer.draw({ x: otherPlayer.x, y: otherPlayer.y, width: 50, height: 50, color: 'blue' });
                    }
                }
                this.ui.update()// Render UI elements
            }

            start() {
                requestAnimationFrame(this.gameLoop);
            }
        }

        const game = new Game();
        game.start();

    </script>
</body>
</html>