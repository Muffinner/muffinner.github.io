<!DOCTYPE html>
<html>
<head>
    <title>Canvas FPS Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100vh;
        }
        .game-ui {
            position: absolute;
            color: #fff;
            padding: 10px;
            pointer-events: none;
        }
        #hud {
            top: 0;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
        }
        #menu {
            display: flex;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        .button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 10px;
            cursor: pointer;
            border-radius: 5px;
            pointer-events: auto;
        }
        .button:hover {
            background-color: #45a049;
        }
        #levelComplete {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        #gameOver {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin-left: -10px;
            margin-top: -10px;
            pointer-events: none;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background-color: #fff;
        }
        #crosshair::before {
            top: 9px;
            left: 0;
            width: 20px;
            height: 2px;
        }
        #crosshair::after {
            top: 0;
            left: 9px;
            width: 2px;
            height: 20px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="crosshair"></div>
    
    <div id="hud" class="game-ui">
        <div>Health: <span id="health">100</span></div>
        <div>Ammo: <span id="ammo">30</span></div>
        <div>Score: <span id="score">0</span></div>
        <div>Level: <span id="level">1</span></div>
        <div>Objectives: <span id="objectives">0/5</span></div>
    </div>
    
    <div id="menu">
        <h1>TACTICAL OPERATIONS</h1>
        <p>A tactical team-based FPS game</p>
        <button class="button" id="startButton">Start Game</button>
        <button class="button" id="instructionsButton">Instructions</button>
    </div>
    
    <div id="levelComplete">
        <h1>Level Complete!</h1>
        <p>Score: <span id="levelScore">0</span></p>
        <button class="button" id="nextLevelButton">Next Level</button>
    </div>
    
    <div id="gameOver">
        <h1>Game Over</h1>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button class="button" id="restartButton">Restart Game</button>
    </div>

    <script>
        // Game Engine Implementation
        // This implements the Single Responsibility Principle by separating concerns into different classes
        
        // Game configuration - responsible for game settings (Single Responsibility)
        class GameConfig {
            constructor() {
                this.mouseSensitivity = 0.2;
                this.moveSpeed = 0.1;
                this.gravity = 0.05;
                this.jumpForce = 0.5;
                this.maxHealth = 100;
                this.maxAmmo = 30;
                this.reloadTime = 2000;
            }
        }
        
        // Vector class - responsible for vector operations (Single Responsibility)
        class Vector {
            constructor(x = 0, y = 0, z = 0) {
                this.x = x;
                this.y = y;
                this.z = z;
            }
            
            add(v) {
                return new Vector(this.x + v.x, this.y + v.y, this.z + v.z);
            }
            
            subtract(v) {
                return new Vector(this.x - v.x, this.y - v.y, this.z - v.z);
            }
            
            scale(s) {
                return new Vector(this.x * s, this.y * s, this.z * s);
            }
            
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            }
            
            normalize() {
                const len = this.length();
                if (len === 0) return new Vector();
                return new Vector(this.x / len, this.y / len, this.z / len);
            }
            
            dot(v) {
                return this.x * v.x + this.y * v.y + this.z * v.z;
            }
        }
        
        // Camera class - responsible for managing the player's view (Single Responsibility)
        class Camera {
            constructor(position, direction) {
                this.position = position || new Vector(0, 1.7, 0);
                this.direction = direction || new Vector(1, 0, 0);
                this.pitch = 0;
                this.yaw = 0;
            }
            
            rotate(dx, dy) {
                this.yaw += dx;
                this.pitch += dy;
                
                // Limit pitch to avoid flipping
                this.pitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, this.pitch));
                
                // Update direction vector
                this.direction.x = Math.cos(this.yaw) * Math.cos(this.pitch);
                this.direction.y = Math.sin(this.pitch);
                this.direction.z = Math.sin(this.yaw) * Math.cos(this.pitch);
                this.direction = this.direction.normalize();
            }
            
            moveForward(distance) {
                const moveVec = new Vector(
                    Math.cos(this.yaw),
                    0,
                    Math.sin(this.yaw)
                ).normalize().scale(distance);
                
                return this.position.add(moveVec);
            }
            
            moveRight(distance) {
                const moveVec = new Vector(
                    Math.cos(this.yaw + Math.PI/2),
                    0,
                    Math.sin(this.yaw + Math.PI/2)
                ).normalize().scale(distance);
                
                return this.position.add(moveVec);
            }
        }
        
        // Entity interface - defines common methods for game objects (Open/Closed Principle)
        class Entity {
            constructor(position, size, type) {
                this.position = position || new Vector();
                this.size = size || new Vector(1, 1, 1);
                this.type = type || 'generic';
                this.id = Math.random().toString(36).substr(2, 9);
            }
            
            update(deltaTime) {
                // To be implemented by subclasses
            }
            
            render(renderer) {
                // To be implemented by subclasses
            }
            
            collidesWith(entity) {
                const dx = Math.abs(this.position.x - entity.position.x);
                const dz = Math.abs(this.position.z - entity.position.z);
                
                return dx < (this.size.x + entity.size.x) / 2 &&
                       dz < (this.size.z + entity.size.z) / 2;
            }
        }
        
        // Actor class - base class for characters (Liskov Substitution Principle)
        class Actor extends Entity {
            constructor(position, size, type, health) {
                super(position, size, type);
                this.health = health || 100;
                this.velocity = new Vector();
                this.onGround = false;
            }
            
            takeDamage(amount) {
                this.health -= amount;
                return this.health <= 0;
            }
            
            update(deltaTime, world) {
                // Apply gravity
                if (!this.onGround) {
                    this.velocity.y -= world.config.gravity;
                }
                
                // Update position
                this.position = this.position.add(this.velocity);
                
                // Floor collision
                if (this.position.y < this.size.y / 2) {
                    this.position.y = this.size.y / 2;
                    this.velocity.y = 0;
                    this.onGround = true;
                } else {
                    this.onGround = false;
                }
                
                // World boundaries
                const bounds = 50; // Map boundary
                if (Math.abs(this.position.x) > bounds) {
                    this.position.x = Math.sign(this.position.x) * bounds;
                }
                if (Math.abs(this.position.z) > bounds) {
                    this.position.z = Math.sign(this.position.z) * bounds;
                }
                
                // Obstacle collision
                for (const obstacle of world.obstacles) {
                    if (this.collidesWith(obstacle)) {
                        // Simple collision response - push away
                        const dx = this.position.x - obstacle.position.x;
                        const dz = this.position.z - obstacle.position.z;
                        
                        if (Math.abs(dx) > Math.abs(dz)) {
                            this.position.x = obstacle.position.x + Math.sign(dx) * (this.size.x + obstacle.size.x) / 2;
                        } else {
                            this.position.z = obstacle.position.z + Math.sign(dz) * (this.size.z + obstacle.size.z) / 2;
                        }
                    }
                }
            }
        }
        
        // Player class - represents the user-controlled character (Inheritance)
        class Player extends Actor {
            constructor(position) {
                super(position, new Vector(0.8, 1.8, 0.8), 'player', 100);
                this.camera = new Camera(this.position.add(new Vector(0, 0.8, 0)));
                this.moveSpeed = 0.15;
                this.ammo = 30;
                this.score = 0;
                this.objectives = 0;
                this.isReloading = false;
                this.team = 'blue';
            }
            
            update(deltaTime, world) {
                super.update(deltaTime, world);
                
                // Update camera position to follow player
                this.camera.position = this.position.add(new Vector(0, 0.8, 0));
            }
            
            shoot() {
                if (this.ammo <= 0 || this.isReloading) {
                    return null;
                }
                
                this.ammo--;
                
                // Create bullet
                const bulletSpeed = 0.5;
                const bulletDirection = this.camera.direction;
                const bulletVelocity = bulletDirection.scale(bulletSpeed);
                const bulletPosition = this.camera.position.add(bulletDirection);
                
                return new Bullet(bulletPosition, bulletVelocity, this.team);
            }
            
            reload() {
                if (this.isReloading || this.ammo === 30) return;
                
                this.isReloading = true;
                setTimeout(() => {
                    this.ammo = 30;
                    this.isReloading = false;
                }, 2000);
            }
            
            jump(world) {
                if (this.onGround) {
                    this.velocity.y = world.config.jumpForce;
                    this.onGround = false;
                }
            }
        }
        
        // Implements enemy AI (Interface Segregation)
        class AI {
            constructor(actor, difficulty = 'normal') {
                this.actor = actor;
                this.difficulty = difficulty;
                this.state = 'patrol';
                this.patrolPoints = [];
                this.currentPatrolIndex = 0;
                this.targetActor = null;
                this.lastShotTime = 0;
                this.path = [];
                
                // Set patrol points based on spawn location
                const radius = 10 + Math.random() * 10;
                for (let i = 0; i < 4; i++) {
                    const angle = (i / 4) * Math.PI * 2;
                    this.patrolPoints.push(new Vector(
                        this.actor.position.x + Math.cos(angle) * radius,
                        this.actor.position.y,
                        this.actor.position.z + Math.sin(angle) * radius
                    ));
                }
            }
            
            update(deltaTime, world) {
                // AI behavior state machine
                switch (this.state) {
                    case 'patrol':
                        this.patrol(deltaTime);
                        
                        // Check if player is visible
                        if (this.canSeeActor(world.player, world)) {
                            this.targetActor = world.player;
                            this.state = 'chase';
                        }
                        break;
                        
                    case 'chase':
                        this.chase(deltaTime, world);
                        
                        // If lost sight of player, return to patrol
                        if (!this.canSeeActor(this.targetActor, world)) {
                            this.state = 'patrol';
                            this.targetActor = null;
                        }
                        break;
                }
            }
            
            patrol(deltaTime) {
                const target = this.patrolPoints[this.currentPatrolIndex];
                const direction = target.subtract(this.actor.position);
                direction.y = 0;
                
                if (direction.length() < 1) {
                    // Reached waypoint, move to next
                    this.currentPatrolIndex = (this.currentPatrolIndex + 1) % this.patrolPoints.length;
                } else {
                    // Move towards waypoint
                    const moveDir = direction.normalize().scale(0.05);
                    this.actor.velocity.x = moveDir.x;
                    this.actor.velocity.z = moveDir.z;
                    
                    // Rotate to face direction
                    const angle = Math.atan2(direction.z, direction.x);
                    this.actor.rotation = angle;
                }
            }
            
            chase(deltaTime, world) {
                const direction = this.targetActor.position.subtract(this.actor.position);
                direction.y = 0;
                
                // Move towards player
                const moveDir = direction.normalize().scale(0.07);
                this.actor.velocity.x = moveDir.x;
                this.actor.velocity.z = moveDir.z;
                
                // Rotate to face player
                const angle = Math.atan2(direction.z, direction.x);
                this.actor.rotation = angle;
                
                // Try to shoot if close enough and timer allows
                const now = Date.now();
                if (direction.length() < 15 && now - this.lastShotTime > 1000) {
                    this.lastShotTime = now;
                    
                    // Create bullet
                    const bulletSpeed = 0.3;
                    const bulletDirection = direction.normalize();
                    const bulletVelocity = bulletDirection.scale(bulletSpeed);
                    const bulletPosition = this.actor.position.add(new Vector(0, 1, 0)).add(bulletDirection);
                    
                    // Add some inaccuracy based on difficulty
                    let accuracy = 0;
                    if (this.difficulty === 'easy') accuracy = 0.2;
                    else if (this.difficulty === 'normal') accuracy = 0.1;
                    else accuracy = 0.05;
                    
                    bulletVelocity.x += (Math.random() - 0.5) * accuracy;
                    bulletVelocity.z += (Math.random() - 0.5) * accuracy;
                    
                    world.bullets.push(new Bullet(bulletPosition, bulletVelocity, this.actor.team));
                }
            }
            
            canSeeActor(actor, world) {
                if (!actor) return false;
                
                const direction = actor.position.add(new Vector(0, 1, 0)).subtract(
                    this.actor.position.add(new Vector(0, 1, 0))
                );
                const distance = direction.length();
                
                // Check distance
                if (distance > 20) return false;
                
                // Check if line of sight is blocked
                for (const obstacle of world.obstacles) {
                    // Simple ray-box intersection check
                    const ray = direction.normalize();
                    const rayStart = this.actor.position.add(new Vector(0, 1, 0));
                    
                    // Check for intersection with obstacle
                    // This is a simplified version - not accurate for all cases
                    const t = (obstacle.position.subtract(rayStart)).dot(ray);
                    if (t > 0 && t < distance) {
                        const point = rayStart.add(ray.scale(t));
                        const dx = Math.abs(point.x - obstacle.position.x);
                        const dy = Math.abs(point.y - obstacle.position.y);
                        const dz = Math.abs(point.z - obstacle.position.z);
                        
                        if (dx < obstacle.size.x/2 && dy < obstacle.size.y/2 && dz < obstacle.size.z/2) {
                            return false;
                        }
                    }
                }
                
                return true;
            }
        }
        
        // Enemy class - computer-controlled opponents (Inheritance)
        class Enemy extends Actor {
            constructor(position, team) {
                super(position, new Vector(0.8, 1.8, 0.8), 'enemy', 100);
                this.team = team || 'red';
                this.rotation = 0;
                this.ai = new AI(this, 'normal');
            }
            
            update(deltaTime, world) {
                super.update(deltaTime, world);
                
                // Update AI
                this.ai.update(deltaTime, world);
            }
        }
        
        // Friendly class - team members (Inheritance & Liskov Substitution)
        class Friendly extends Actor {
            constructor(position) {
                super(position, new Vector(0.8, 1.8, 0.8), 'friendly', 100);
                this.team = 'blue';
                this.rotation = 0;
                this.ai = new AI(this, 'normal');
                this.role = Math.random() < 0.5 ? 'support' : 'assault';
            }
            
            update(deltaTime, world) {
                super.update(deltaTime, world);
                
                // Update AI
                this.ai.update(deltaTime, world);
                
                // Team-specific behavior
                if (this.role === 'support' && Math.random() < 0.001) {
                    // Occasionally heal nearby teammates
                    for (const actor of world.actors) {
                        if (actor.team === this.team && actor !== this) {
                            const distance = actor.position.subtract(this.position).length();
                            if (distance < 5 && actor.health < 100) {
                                actor.health = Math.min(100, actor.health + 10);
                            }
                        }
                    }
                }
            }
        }
        
        // Bullet class - projectiles fired by actors
        class Bullet extends Entity {
            constructor(position, velocity, team) {
                super(position, new Vector(0.1, 0.1, 0.1), 'bullet');
                this.velocity = velocity;
                this.team = team;
                this.damage = 25;
                this.lifetime = 100;
            }
            
            update(deltaTime, world) {
                this.position = this.position.add(this.velocity);
                this.lifetime--;
                
                // Check collisions with world
                for (const obstacle of world.obstacles) {
                    if (this.collidesWith(obstacle)) {
                        this.lifetime = 0;
                        return;
                    }
                }
                
                // Check collisions with actors
                for (const actor of world.actors) {
                    if (actor.team !== this.team && this.collidesWith(actor)) {
                        const isDead = actor.takeDamage(this.damage);
                        
                        // Award points if player hit an enemy
                        if (this.team === 'blue' && actor.type === 'enemy' && isDead) {
                            world.player.score += 100;
                        }
                        
                        // Damage player if hit by enemy
                        if (actor.type === 'player') {
                            document.getElementById('health').textContent = actor.health;
                        }
                        
                        this.lifetime = 0;
                        return;
                    }
                }
            }
        }
        
        // Objective class - objects to collect for mission completion
        class Objective extends Entity {
            constructor(position) {
                super(position, new Vector(0.5, 0.5, 0.5), 'objective');
                this.collected = false;
                this.pulseTime = 0;
            }
            
            update(deltaTime, world) {
                if (this.collected) return;
                
                this.pulseTime += deltaTime;
                
                // Check if player is close enough to collect
                const distance = world.player.position.subtract(this.position).length();
                if (distance < 1.5) {
                    this.collected = true;
                    world.player.objectives++;
                    world.player.score += 250;
                    document.getElementById('objectives').textContent = 
                        `${world.player.objectives}/${world.levelObjectives}`;
                    
                    // Check if all objectives are collected
                    if (world.player.objectives >= world.levelObjectives) {
                        world.levelComplete();
                    }
                }
            }
        }
        
        // Obstacle class - level geometry
        class Obstacle extends Entity {
            constructor(position, size, color) {
                super(position, size, 'obstacle');
                this.color = color || '#555';
            }
        }
        
        // WorldRenderer - handles 3D rendering (Dependency Inversion)
        class WorldRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.context = canvas.getContext('2d');
                this.width = canvas.width;
                this.height = canvas.height;
                
                // Depth buffer - used for correct rendering order
                this.depthBuffer = [];
                
                // Colors
                this.colors = {
                    ground: '#8B8B83',
                    sky: '#87CEEB',
                    enemy: '#FF4444',
                    friendly: '#4444FF',
                    bullet: '#FFFF00',
                    objective: '#44FF44',
                    player: '#4444FF'
                };
            }
            
            clear() {
                this.context.clearRect(0, 0, this.width, this.height);
                this.depthBuffer = [];
            }
            
            renderWorld(world) {
                this.clear();
                
                const camera = world.player.camera;
                
                // Draw sky and ground
                this.context.fillStyle = this.colors.sky;
                this.context.fillRect(0, 0, this.width, this.height / 2);
                this.context.fillStyle = this.colors.ground;
                this.context.fillRect(0, this.height / 2, this.width, this.height / 2);
                
                // Draw entities
                for (const obstacle of world.obstacles) {
                    this.renderCube(camera, obstacle.position, obstacle.size, obstacle.color);
                }
                
                // Draw actors
                for (const actor of world.actors) {
                    if (actor === world.player) continue; // Skip player
                    
                    const color = actor.team === 'blue' ? this.colors.friendly : this.colors.enemy;
                    this.renderCube(camera, actor.position, actor.size, color);
                }
                
                // Draw objectives
                for (const objective of world.objectives) {
                    if (!objective.collected) {
                        // Pulsing effect
                        const pulseScale = 1 + Math.sin(objective.pulseTime * 0.1) * 0.1;
                        const adjustedSize = objective.size.scale(pulseScale);
                        this.renderCube(camera, objective.position, adjustedSize, this.colors.objective);
                    }
                }
                
                // Draw bullets
                for (const bullet of world.bullets) {
                    this.renderCube(camera, bullet.position, bullet.size, this.colors.bullet);
                }
                
                // Sort depth buffer and render from back to front
                this.depthBuffer.sort((a, b) => b.depth - a.depth);
                
                for (const item of this.depthBuffer) {
                    this.context.fillStyle = item.color;
                    this.context.fillRect(item.x, item.y, item.width, item.height);
                }
            }
            
            // Cube rendering function
            renderCube(camera, position, size, color) {
                // Calculate direction to entity
                const direction = position.subtract(camera.position);
                
                // Calculate distance
                const distance = direction.length();
                
                // Don't render if too far
                if (distance > 50) return;
                
                // Calculate dot product with camera direction for view frustum culling
                const dot = direction.normalize().dot(camera.direction);
                
                // Only render if in front of camera
                if (dot > 0.1) {
                    // Project 3D position to 2D screen coordinates
                    const fov = 70 * Math.PI / 180;
                    const aspectRatio = this.width / this.height;
                    
                    // Calculate angle between camera direction and direction to entity
                    const rightVec = new Vector(
                        Math.cos(camera.yaw + Math.PI / 2),
                        0,
                        Math.sin(camera.yaw + Math.PI / 2)
                    );
                    
                    const upVec = new Vector(0, 1, 0);
                    
                    // Calculate screen position
                    const screenX = this.width / 2 * (1 + direction.dot(rightVec) / (distance * Math.tan(fov / 2) * aspectRatio));
                    const screenY = this.height / 2 * (1 - direction.dot(upVec) / (distance * Math.tan(fov / 2)));
                    
                    // Calculate screen size based on distance
                    const scale = 500 / distance;
                    const screenWidth = size.x * scale;
                    const screenHeight = size.y * scale;
                    
                    // Add to depth buffer for correct rendering order
                    this.depthBuffer.push({
                        x: screenX - screenWidth / 2,
                        y: screenY - screenHeight / 2,
                        width: screenWidth,
                        height: screenHeight,
                        color: color,
                        depth: distance
                    });
                }
            }
        }
        
        // LevelGenerator - creates game levels (Dependency Inversion)
        class LevelGenerator {
            constructor() {
                this.difficulty = 1;
            }
            
            generateLevel(level) {
                const world = {
                    obstacles: [],
                    objectives: [],
                    actors: [],
                    levelObjectives: 5
                };
                
                // Adjust difficulty
                const enemyCount = 3 + level * 2;
                const friendlyCount = 2 + Math.floor(level / 2);
                
                // Generate level layout based on level number
                switch (level) {
                    case 1:
                        // Tutorial level - simple open field with few obstacles
                        this.generateWarehouse(world);
                        break;
                    case 2:
                        // Urban level - city blocks
                        this.generateUrban(world);
                        break;
                    case 3:
                        // Forest level - trees and hills
                        this.generateForest(world);
                        break;
                    default:
                        // Procedural level for higher levels
                        this.generateProcedural(world, level);
                        break;
                }
                
                // Add enemies
                for (let i = 0; i < enemyCount; i++) {
                    const pos = this.findSpawnPosition(world, 20, 40);
                    world.actors.push(new Enemy(pos, 'red'));
                }
                
                // Add friendlies
                for (let i = 0; i < friendlyCount; i++) {
                    const pos = this.findSpawnPosition(world, 5, 15);
                    world.actors.push(new Friendly(pos));
                }
                
                // Add objectives
                for (let i = 0; i < world.levelObjectives; i++) {
                    const pos = this.findSpawnPosition(world, 10, 40);
                    world.objectives.push(new Objective(pos));
                }
                
                return world;
            }
            
            // Level generation methods
            generateWarehouse(world) {
                // Outer walls
                const size = 40;
                
                // Floor
                world.obstacles.push(new Obstacle(new Vector(0, -0.5, 0), new Vector(size*2, 1, size*2), '#555'));
                
                // Walls
                world.obstacles.push(new Obstacle(new Vector(-size, 5, 0), new Vector(1, 10, size*2), '#777'));
                world.obstacles.push(new Obstacle(new Vector(size, 5, 0), new Vector(1, 10, size*2), '#777'));
                world.obstacles.push(new